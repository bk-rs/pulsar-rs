// This file is generated by rust-protobuf 2.22.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `PulsarApi.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_0;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Schema {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    schema_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    field_type: ::std::option::Option<Schema_Type>,
    pub properties: ::protobuf::RepeatedField<KeyValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Schema {
    fn default() -> &'a Schema {
        <Schema as ::protobuf::Message>::default_instance()
    }
}

impl Schema {
    pub fn new() -> Schema {
        ::std::default::Default::default()
    }

    // required string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bytes schema_data = 3;


    pub fn get_schema_data(&self) -> &[u8] {
        match self.schema_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_schema_data(&mut self) {
        self.schema_data.clear();
    }

    pub fn has_schema_data(&self) -> bool {
        self.schema_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.schema_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.schema_data.is_none() {
            self.schema_data.set_default();
        }
        self.schema_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema_data(&mut self) -> ::std::vec::Vec<u8> {
        self.schema_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required .pulsar.proto.Schema.Type type = 4;


    pub fn get_field_type(&self) -> Schema_Type {
        self.field_type.unwrap_or(Schema_Type::None)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Schema_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // repeated .pulsar.proto.KeyValue properties = 5;


    pub fn get_properties(&self) -> &[KeyValue] {
        &self.properties
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<KeyValue>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<KeyValue> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<KeyValue> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Schema {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.schema_data.is_none() {
            return false;
        }
        if self.field_type.is_none() {
            return false;
        }
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.schema_data)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.schema_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.schema_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.properties {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Schema {
        Schema::new()
    }

    fn default_instance() -> &'static Schema {
        static instance: ::protobuf::rt::LazyV2<Schema> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Schema::new)
    }
}

impl ::protobuf::Clear for Schema {
    fn clear(&mut self) {
        self.name.clear();
        self.schema_data.clear();
        self.field_type = ::std::option::Option::None;
        self.properties.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Schema {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Schema_Type {
    None = 0,
    String = 1,
    Json = 2,
    Protobuf = 3,
    Avro = 4,
    Bool = 5,
    Int8 = 6,
    Int16 = 7,
    Int32 = 8,
    Int64 = 9,
    Float = 10,
    Double = 11,
    Date = 12,
    Time = 13,
    Timestamp = 14,
    KeyValue = 15,
    Instant = 16,
    LocalDate = 17,
    LocalTime = 18,
    LocalDateTime = 19,
    ProtobufNative = 20,
}

impl ::protobuf::ProtobufEnum for Schema_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Schema_Type> {
        match value {
            0 => ::std::option::Option::Some(Schema_Type::None),
            1 => ::std::option::Option::Some(Schema_Type::String),
            2 => ::std::option::Option::Some(Schema_Type::Json),
            3 => ::std::option::Option::Some(Schema_Type::Protobuf),
            4 => ::std::option::Option::Some(Schema_Type::Avro),
            5 => ::std::option::Option::Some(Schema_Type::Bool),
            6 => ::std::option::Option::Some(Schema_Type::Int8),
            7 => ::std::option::Option::Some(Schema_Type::Int16),
            8 => ::std::option::Option::Some(Schema_Type::Int32),
            9 => ::std::option::Option::Some(Schema_Type::Int64),
            10 => ::std::option::Option::Some(Schema_Type::Float),
            11 => ::std::option::Option::Some(Schema_Type::Double),
            12 => ::std::option::Option::Some(Schema_Type::Date),
            13 => ::std::option::Option::Some(Schema_Type::Time),
            14 => ::std::option::Option::Some(Schema_Type::Timestamp),
            15 => ::std::option::Option::Some(Schema_Type::KeyValue),
            16 => ::std::option::Option::Some(Schema_Type::Instant),
            17 => ::std::option::Option::Some(Schema_Type::LocalDate),
            18 => ::std::option::Option::Some(Schema_Type::LocalTime),
            19 => ::std::option::Option::Some(Schema_Type::LocalDateTime),
            20 => ::std::option::Option::Some(Schema_Type::ProtobufNative),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Schema_Type] = &[
            Schema_Type::None,
            Schema_Type::String,
            Schema_Type::Json,
            Schema_Type::Protobuf,
            Schema_Type::Avro,
            Schema_Type::Bool,
            Schema_Type::Int8,
            Schema_Type::Int16,
            Schema_Type::Int32,
            Schema_Type::Int64,
            Schema_Type::Float,
            Schema_Type::Double,
            Schema_Type::Date,
            Schema_Type::Time,
            Schema_Type::Timestamp,
            Schema_Type::KeyValue,
            Schema_Type::Instant,
            Schema_Type::LocalDate,
            Schema_Type::LocalTime,
            Schema_Type::LocalDateTime,
            Schema_Type::ProtobufNative,
        ];
        values
    }
}

impl ::std::marker::Copy for Schema_Type {
}

impl ::std::default::Default for Schema_Type {
    fn default() -> Self {
        Schema_Type::None
    }
}

impl ::protobuf::reflect::ProtobufValue for Schema_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MessageIdData {
    // message fields
    ledgerId: ::std::option::Option<u64>,
    entryId: ::std::option::Option<u64>,
    partition: ::std::option::Option<i32>,
    batch_index: ::std::option::Option<i32>,
    pub ack_set: ::std::vec::Vec<i64>,
    batch_size: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageIdData {
    fn default() -> &'a MessageIdData {
        <MessageIdData as ::protobuf::Message>::default_instance()
    }
}

impl MessageIdData {
    pub fn new() -> MessageIdData {
        ::std::default::Default::default()
    }

    // required uint64 ledgerId = 1;


    pub fn get_ledgerId(&self) -> u64 {
        self.ledgerId.unwrap_or(0)
    }
    pub fn clear_ledgerId(&mut self) {
        self.ledgerId = ::std::option::Option::None;
    }

    pub fn has_ledgerId(&self) -> bool {
        self.ledgerId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerId(&mut self, v: u64) {
        self.ledgerId = ::std::option::Option::Some(v);
    }

    // required uint64 entryId = 2;


    pub fn get_entryId(&self) -> u64 {
        self.entryId.unwrap_or(0)
    }
    pub fn clear_entryId(&mut self) {
        self.entryId = ::std::option::Option::None;
    }

    pub fn has_entryId(&self) -> bool {
        self.entryId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entryId(&mut self, v: u64) {
        self.entryId = ::std::option::Option::Some(v);
    }

    // optional int32 partition = 3;


    pub fn get_partition(&self) -> i32 {
        self.partition.unwrap_or(-1i32)
    }
    pub fn clear_partition(&mut self) {
        self.partition = ::std::option::Option::None;
    }

    pub fn has_partition(&self) -> bool {
        self.partition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition(&mut self, v: i32) {
        self.partition = ::std::option::Option::Some(v);
    }

    // optional int32 batch_index = 4;


    pub fn get_batch_index(&self) -> i32 {
        self.batch_index.unwrap_or(-1i32)
    }
    pub fn clear_batch_index(&mut self) {
        self.batch_index = ::std::option::Option::None;
    }

    pub fn has_batch_index(&self) -> bool {
        self.batch_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_batch_index(&mut self, v: i32) {
        self.batch_index = ::std::option::Option::Some(v);
    }

    // repeated int64 ack_set = 5;


    pub fn get_ack_set(&self) -> &[i64] {
        &self.ack_set
    }
    pub fn clear_ack_set(&mut self) {
        self.ack_set.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_set(&mut self, v: ::std::vec::Vec<i64>) {
        self.ack_set = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_set(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.ack_set
    }

    // Take field
    pub fn take_ack_set(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.ack_set, ::std::vec::Vec::new())
    }

    // optional int32 batch_size = 6;


    pub fn get_batch_size(&self) -> i32 {
        self.batch_size.unwrap_or(0)
    }
    pub fn clear_batch_size(&mut self) {
        self.batch_size = ::std::option::Option::None;
    }

    pub fn has_batch_size(&self) -> bool {
        self.batch_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_batch_size(&mut self, v: i32) {
        self.batch_size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MessageIdData {
    fn is_initialized(&self) -> bool {
        if self.ledgerId.is_none() {
            return false;
        }
        if self.entryId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ledgerId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.entryId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.partition = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.batch_index = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.ack_set)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.batch_size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ledgerId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.entryId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.partition {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.batch_index {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.ack_set {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.batch_size {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ledgerId {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.entryId {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.partition {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.batch_index {
            os.write_int32(4, v)?;
        }
        for v in &self.ack_set {
            os.write_int64(5, *v)?;
        };
        if let Some(v) = self.batch_size {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageIdData {
        MessageIdData::new()
    }

    fn default_instance() -> &'static MessageIdData {
        static instance: ::protobuf::rt::LazyV2<MessageIdData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MessageIdData::new)
    }
}

impl ::protobuf::Clear for MessageIdData {
    fn clear(&mut self) {
        self.ledgerId = ::std::option::Option::None;
        self.entryId = ::std::option::Option::None;
        self.partition = ::std::option::Option::None;
        self.batch_index = ::std::option::Option::None;
        self.ack_set.clear();
        self.batch_size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageIdData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct KeyValue {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyValue {
    fn default() -> &'a KeyValue {
        <KeyValue as ::protobuf::Message>::default_instance()
    }
}

impl KeyValue {
    pub fn new() -> KeyValue {
        ::std::default::Default::default()
    }

    // required string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for KeyValue {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyValue {
        KeyValue::new()
    }

    fn default_instance() -> &'static KeyValue {
        static instance: ::protobuf::rt::LazyV2<KeyValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyValue::new)
    }
}

impl ::protobuf::Clear for KeyValue {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct KeyLongValue {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyLongValue {
    fn default() -> &'a KeyLongValue {
        <KeyLongValue as ::protobuf::Message>::default_instance()
    }
}

impl KeyLongValue {
    pub fn new() -> KeyLongValue {
        ::std::default::Default::default()
    }

    // required string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 value = 2;


    pub fn get_value(&self) -> u64 {
        self.value.unwrap_or(0)
    }
    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u64) {
        self.value = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for KeyLongValue {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.value {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyLongValue {
        KeyLongValue::new()
    }

    fn default_instance() -> &'static KeyLongValue {
        static instance: ::protobuf::rt::LazyV2<KeyLongValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyLongValue::new)
    }
}

impl ::protobuf::Clear for KeyLongValue {
    fn clear(&mut self) {
        self.key.clear();
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyLongValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IntRange {
    // message fields
    start: ::std::option::Option<i32>,
    end: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IntRange {
    fn default() -> &'a IntRange {
        <IntRange as ::protobuf::Message>::default_instance()
    }
}

impl IntRange {
    pub fn new() -> IntRange {
        ::std::default::Default::default()
    }

    // required int32 start = 1;


    pub fn get_start(&self) -> i32 {
        self.start.unwrap_or(0)
    }
    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i32) {
        self.start = ::std::option::Option::Some(v);
    }

    // required int32 end = 2;


    pub fn get_end(&self) -> i32 {
        self.end.unwrap_or(0)
    }
    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None;
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: i32) {
        self.end = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for IntRange {
    fn is_initialized(&self) -> bool {
        if self.start.is_none() {
            return false;
        }
        if self.end.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.start = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.end = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.start {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.end {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.start {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.end {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IntRange {
        IntRange::new()
    }

    fn default_instance() -> &'static IntRange {
        static instance: ::protobuf::rt::LazyV2<IntRange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IntRange::new)
    }
}

impl ::protobuf::Clear for IntRange {
    fn clear(&mut self) {
        self.start = ::std::option::Option::None;
        self.end = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IntRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EncryptionKeys {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub metadata: ::protobuf::RepeatedField<KeyValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncryptionKeys {
    fn default() -> &'a EncryptionKeys {
        <EncryptionKeys as ::protobuf::Message>::default_instance()
    }
}

impl EncryptionKeys {
    pub fn new() -> EncryptionKeys {
        ::std::default::Default::default()
    }

    // required string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        match self.value.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        self.value.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated .pulsar.proto.KeyValue metadata = 3;


    pub fn get_metadata(&self) -> &[KeyValue] {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::RepeatedField<KeyValue>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::RepeatedField<KeyValue> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::RepeatedField<KeyValue> {
        ::std::mem::replace(&mut self.metadata, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EncryptionKeys {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        for value in &self.metadata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_bytes(2, &v)?;
        }
        for v in &self.metadata {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptionKeys {
        EncryptionKeys::new()
    }

    fn default_instance() -> &'static EncryptionKeys {
        static instance: ::protobuf::rt::LazyV2<EncryptionKeys> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EncryptionKeys::new)
    }
}

impl ::protobuf::Clear for EncryptionKeys {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptionKeys {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MessageMetadata {
    // message fields
    producer_name: ::protobuf::SingularField<::std::string::String>,
    sequence_id: ::std::option::Option<u64>,
    publish_time: ::std::option::Option<u64>,
    pub properties: ::protobuf::RepeatedField<KeyValue>,
    replicated_from: ::protobuf::SingularField<::std::string::String>,
    partition_key: ::protobuf::SingularField<::std::string::String>,
    pub replicate_to: ::protobuf::RepeatedField<::std::string::String>,
    compression: ::std::option::Option<CompressionType>,
    uncompressed_size: ::std::option::Option<u32>,
    num_messages_in_batch: ::std::option::Option<i32>,
    event_time: ::std::option::Option<u64>,
    pub encryption_keys: ::protobuf::RepeatedField<EncryptionKeys>,
    encryption_algo: ::protobuf::SingularField<::std::string::String>,
    encryption_param: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    schema_version: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    partition_key_b64_encoded: ::std::option::Option<bool>,
    ordering_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    deliver_at_time: ::std::option::Option<i64>,
    marker_type: ::std::option::Option<i32>,
    txnid_least_bits: ::std::option::Option<u64>,
    txnid_most_bits: ::std::option::Option<u64>,
    highest_sequence_id: ::std::option::Option<u64>,
    null_value: ::std::option::Option<bool>,
    uuid: ::protobuf::SingularField<::std::string::String>,
    num_chunks_from_msg: ::std::option::Option<i32>,
    total_chunk_msg_size: ::std::option::Option<i32>,
    chunk_id: ::std::option::Option<i32>,
    null_partition_key: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageMetadata {
    fn default() -> &'a MessageMetadata {
        <MessageMetadata as ::protobuf::Message>::default_instance()
    }
}

impl MessageMetadata {
    pub fn new() -> MessageMetadata {
        ::std::default::Default::default()
    }

    // required string producer_name = 1;


    pub fn get_producer_name(&self) -> &str {
        match self.producer_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_producer_name(&mut self) {
        self.producer_name.clear();
    }

    pub fn has_producer_name(&self) -> bool {
        self.producer_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_name(&mut self, v: ::std::string::String) {
        self.producer_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_producer_name(&mut self) -> &mut ::std::string::String {
        if self.producer_name.is_none() {
            self.producer_name.set_default();
        }
        self.producer_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_producer_name(&mut self) -> ::std::string::String {
        self.producer_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 sequence_id = 2;


    pub fn get_sequence_id(&self) -> u64 {
        self.sequence_id.unwrap_or(0)
    }
    pub fn clear_sequence_id(&mut self) {
        self.sequence_id = ::std::option::Option::None;
    }

    pub fn has_sequence_id(&self) -> bool {
        self.sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_id(&mut self, v: u64) {
        self.sequence_id = ::std::option::Option::Some(v);
    }

    // required uint64 publish_time = 3;


    pub fn get_publish_time(&self) -> u64 {
        self.publish_time.unwrap_or(0)
    }
    pub fn clear_publish_time(&mut self) {
        self.publish_time = ::std::option::Option::None;
    }

    pub fn has_publish_time(&self) -> bool {
        self.publish_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publish_time(&mut self, v: u64) {
        self.publish_time = ::std::option::Option::Some(v);
    }

    // repeated .pulsar.proto.KeyValue properties = 4;


    pub fn get_properties(&self) -> &[KeyValue] {
        &self.properties
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<KeyValue>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<KeyValue> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<KeyValue> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }

    // optional string replicated_from = 5;


    pub fn get_replicated_from(&self) -> &str {
        match self.replicated_from.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_replicated_from(&mut self) {
        self.replicated_from.clear();
    }

    pub fn has_replicated_from(&self) -> bool {
        self.replicated_from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicated_from(&mut self, v: ::std::string::String) {
        self.replicated_from = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_replicated_from(&mut self) -> &mut ::std::string::String {
        if self.replicated_from.is_none() {
            self.replicated_from.set_default();
        }
        self.replicated_from.as_mut().unwrap()
    }

    // Take field
    pub fn take_replicated_from(&mut self) -> ::std::string::String {
        self.replicated_from.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string partition_key = 6;


    pub fn get_partition_key(&self) -> &str {
        match self.partition_key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_partition_key(&mut self) {
        self.partition_key.clear();
    }

    pub fn has_partition_key(&self) -> bool {
        self.partition_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition_key(&mut self, v: ::std::string::String) {
        self.partition_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_partition_key(&mut self) -> &mut ::std::string::String {
        if self.partition_key.is_none() {
            self.partition_key.set_default();
        }
        self.partition_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_partition_key(&mut self) -> ::std::string::String {
        self.partition_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string replicate_to = 7;


    pub fn get_replicate_to(&self) -> &[::std::string::String] {
        &self.replicate_to
    }
    pub fn clear_replicate_to(&mut self) {
        self.replicate_to.clear();
    }

    // Param is passed by value, moved
    pub fn set_replicate_to(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.replicate_to = v;
    }

    // Mutable pointer to the field.
    pub fn mut_replicate_to(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.replicate_to
    }

    // Take field
    pub fn take_replicate_to(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.replicate_to, ::protobuf::RepeatedField::new())
    }

    // optional .pulsar.proto.CompressionType compression = 8;


    pub fn get_compression(&self) -> CompressionType {
        self.compression.unwrap_or(CompressionType::NONE)
    }
    pub fn clear_compression(&mut self) {
        self.compression = ::std::option::Option::None;
    }

    pub fn has_compression(&self) -> bool {
        self.compression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compression(&mut self, v: CompressionType) {
        self.compression = ::std::option::Option::Some(v);
    }

    // optional uint32 uncompressed_size = 9;


    pub fn get_uncompressed_size(&self) -> u32 {
        self.uncompressed_size.unwrap_or(0u32)
    }
    pub fn clear_uncompressed_size(&mut self) {
        self.uncompressed_size = ::std::option::Option::None;
    }

    pub fn has_uncompressed_size(&self) -> bool {
        self.uncompressed_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uncompressed_size(&mut self, v: u32) {
        self.uncompressed_size = ::std::option::Option::Some(v);
    }

    // optional int32 num_messages_in_batch = 11;


    pub fn get_num_messages_in_batch(&self) -> i32 {
        self.num_messages_in_batch.unwrap_or(1i32)
    }
    pub fn clear_num_messages_in_batch(&mut self) {
        self.num_messages_in_batch = ::std::option::Option::None;
    }

    pub fn has_num_messages_in_batch(&self) -> bool {
        self.num_messages_in_batch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_messages_in_batch(&mut self, v: i32) {
        self.num_messages_in_batch = ::std::option::Option::Some(v);
    }

    // optional uint64 event_time = 12;


    pub fn get_event_time(&self) -> u64 {
        self.event_time.unwrap_or(0u64)
    }
    pub fn clear_event_time(&mut self) {
        self.event_time = ::std::option::Option::None;
    }

    pub fn has_event_time(&self) -> bool {
        self.event_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_time(&mut self, v: u64) {
        self.event_time = ::std::option::Option::Some(v);
    }

    // repeated .pulsar.proto.EncryptionKeys encryption_keys = 13;


    pub fn get_encryption_keys(&self) -> &[EncryptionKeys] {
        &self.encryption_keys
    }
    pub fn clear_encryption_keys(&mut self) {
        self.encryption_keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_encryption_keys(&mut self, v: ::protobuf::RepeatedField<EncryptionKeys>) {
        self.encryption_keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_encryption_keys(&mut self) -> &mut ::protobuf::RepeatedField<EncryptionKeys> {
        &mut self.encryption_keys
    }

    // Take field
    pub fn take_encryption_keys(&mut self) -> ::protobuf::RepeatedField<EncryptionKeys> {
        ::std::mem::replace(&mut self.encryption_keys, ::protobuf::RepeatedField::new())
    }

    // optional string encryption_algo = 14;


    pub fn get_encryption_algo(&self) -> &str {
        match self.encryption_algo.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_encryption_algo(&mut self) {
        self.encryption_algo.clear();
    }

    pub fn has_encryption_algo(&self) -> bool {
        self.encryption_algo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_algo(&mut self, v: ::std::string::String) {
        self.encryption_algo = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_algo(&mut self) -> &mut ::std::string::String {
        if self.encryption_algo.is_none() {
            self.encryption_algo.set_default();
        }
        self.encryption_algo.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryption_algo(&mut self) -> ::std::string::String {
        self.encryption_algo.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes encryption_param = 15;


    pub fn get_encryption_param(&self) -> &[u8] {
        match self.encryption_param.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_encryption_param(&mut self) {
        self.encryption_param.clear();
    }

    pub fn has_encryption_param(&self) -> bool {
        self.encryption_param.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_param(&mut self, v: ::std::vec::Vec<u8>) {
        self.encryption_param = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_param(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encryption_param.is_none() {
            self.encryption_param.set_default();
        }
        self.encryption_param.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryption_param(&mut self) -> ::std::vec::Vec<u8> {
        self.encryption_param.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes schema_version = 16;


    pub fn get_schema_version(&self) -> &[u8] {
        match self.schema_version.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_schema_version(&mut self) {
        self.schema_version.clear();
    }

    pub fn has_schema_version(&self) -> bool {
        self.schema_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema_version(&mut self, v: ::std::vec::Vec<u8>) {
        self.schema_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema_version(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.schema_version.is_none() {
            self.schema_version.set_default();
        }
        self.schema_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema_version(&mut self) -> ::std::vec::Vec<u8> {
        self.schema_version.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool partition_key_b64_encoded = 17;


    pub fn get_partition_key_b64_encoded(&self) -> bool {
        self.partition_key_b64_encoded.unwrap_or(false)
    }
    pub fn clear_partition_key_b64_encoded(&mut self) {
        self.partition_key_b64_encoded = ::std::option::Option::None;
    }

    pub fn has_partition_key_b64_encoded(&self) -> bool {
        self.partition_key_b64_encoded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition_key_b64_encoded(&mut self, v: bool) {
        self.partition_key_b64_encoded = ::std::option::Option::Some(v);
    }

    // optional bytes ordering_key = 18;


    pub fn get_ordering_key(&self) -> &[u8] {
        match self.ordering_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ordering_key(&mut self) {
        self.ordering_key.clear();
    }

    pub fn has_ordering_key(&self) -> bool {
        self.ordering_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordering_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.ordering_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ordering_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ordering_key.is_none() {
            self.ordering_key.set_default();
        }
        self.ordering_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_ordering_key(&mut self) -> ::std::vec::Vec<u8> {
        self.ordering_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int64 deliver_at_time = 19;


    pub fn get_deliver_at_time(&self) -> i64 {
        self.deliver_at_time.unwrap_or(0)
    }
    pub fn clear_deliver_at_time(&mut self) {
        self.deliver_at_time = ::std::option::Option::None;
    }

    pub fn has_deliver_at_time(&self) -> bool {
        self.deliver_at_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deliver_at_time(&mut self, v: i64) {
        self.deliver_at_time = ::std::option::Option::Some(v);
    }

    // optional int32 marker_type = 20;


    pub fn get_marker_type(&self) -> i32 {
        self.marker_type.unwrap_or(0)
    }
    pub fn clear_marker_type(&mut self) {
        self.marker_type = ::std::option::Option::None;
    }

    pub fn has_marker_type(&self) -> bool {
        self.marker_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_marker_type(&mut self, v: i32) {
        self.marker_type = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_least_bits = 22;


    pub fn get_txnid_least_bits(&self) -> u64 {
        self.txnid_least_bits.unwrap_or(0)
    }
    pub fn clear_txnid_least_bits(&mut self) {
        self.txnid_least_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_least_bits(&self) -> bool {
        self.txnid_least_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_least_bits(&mut self, v: u64) {
        self.txnid_least_bits = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_most_bits = 23;


    pub fn get_txnid_most_bits(&self) -> u64 {
        self.txnid_most_bits.unwrap_or(0)
    }
    pub fn clear_txnid_most_bits(&mut self) {
        self.txnid_most_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_most_bits(&self) -> bool {
        self.txnid_most_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_most_bits(&mut self, v: u64) {
        self.txnid_most_bits = ::std::option::Option::Some(v);
    }

    // optional uint64 highest_sequence_id = 24;


    pub fn get_highest_sequence_id(&self) -> u64 {
        self.highest_sequence_id.unwrap_or(0u64)
    }
    pub fn clear_highest_sequence_id(&mut self) {
        self.highest_sequence_id = ::std::option::Option::None;
    }

    pub fn has_highest_sequence_id(&self) -> bool {
        self.highest_sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_highest_sequence_id(&mut self, v: u64) {
        self.highest_sequence_id = ::std::option::Option::Some(v);
    }

    // optional bool null_value = 25;


    pub fn get_null_value(&self) -> bool {
        self.null_value.unwrap_or(false)
    }
    pub fn clear_null_value(&mut self) {
        self.null_value = ::std::option::Option::None;
    }

    pub fn has_null_value(&self) -> bool {
        self.null_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_null_value(&mut self, v: bool) {
        self.null_value = ::std::option::Option::Some(v);
    }

    // optional string uuid = 26;


    pub fn get_uuid(&self) -> &str {
        match self.uuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    pub fn has_uuid(&self) -> bool {
        self.uuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        if self.uuid.is_none() {
            self.uuid.set_default();
        }
        self.uuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        self.uuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 num_chunks_from_msg = 27;


    pub fn get_num_chunks_from_msg(&self) -> i32 {
        self.num_chunks_from_msg.unwrap_or(0)
    }
    pub fn clear_num_chunks_from_msg(&mut self) {
        self.num_chunks_from_msg = ::std::option::Option::None;
    }

    pub fn has_num_chunks_from_msg(&self) -> bool {
        self.num_chunks_from_msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_chunks_from_msg(&mut self, v: i32) {
        self.num_chunks_from_msg = ::std::option::Option::Some(v);
    }

    // optional int32 total_chunk_msg_size = 28;


    pub fn get_total_chunk_msg_size(&self) -> i32 {
        self.total_chunk_msg_size.unwrap_or(0)
    }
    pub fn clear_total_chunk_msg_size(&mut self) {
        self.total_chunk_msg_size = ::std::option::Option::None;
    }

    pub fn has_total_chunk_msg_size(&self) -> bool {
        self.total_chunk_msg_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_chunk_msg_size(&mut self, v: i32) {
        self.total_chunk_msg_size = ::std::option::Option::Some(v);
    }

    // optional int32 chunk_id = 29;


    pub fn get_chunk_id(&self) -> i32 {
        self.chunk_id.unwrap_or(0)
    }
    pub fn clear_chunk_id(&mut self) {
        self.chunk_id = ::std::option::Option::None;
    }

    pub fn has_chunk_id(&self) -> bool {
        self.chunk_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chunk_id(&mut self, v: i32) {
        self.chunk_id = ::std::option::Option::Some(v);
    }

    // optional bool null_partition_key = 30;


    pub fn get_null_partition_key(&self) -> bool {
        self.null_partition_key.unwrap_or(false)
    }
    pub fn clear_null_partition_key(&mut self) {
        self.null_partition_key = ::std::option::Option::None;
    }

    pub fn has_null_partition_key(&self) -> bool {
        self.null_partition_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_null_partition_key(&mut self, v: bool) {
        self.null_partition_key = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MessageMetadata {
    fn is_initialized(&self) -> bool {
        if self.producer_name.is_none() {
            return false;
        }
        if self.sequence_id.is_none() {
            return false;
        }
        if self.publish_time.is_none() {
            return false;
        }
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.encryption_keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.producer_name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.publish_time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.replicated_from)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.partition_key)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.replicate_to)?;
                },
                8 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.compression, 8, &mut self.unknown_fields)?
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.uncompressed_size = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_messages_in_batch = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.event_time = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.encryption_keys)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.encryption_algo)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.encryption_param)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.schema_version)?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.partition_key_b64_encoded = ::std::option::Option::Some(tmp);
                },
                18 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ordering_key)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.deliver_at_time = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.marker_type = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_least_bits = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_most_bits = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.highest_sequence_id = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.null_value = ::std::option::Option::Some(tmp);
                },
                26 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uuid)?;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_chunks_from_msg = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.total_chunk_msg_size = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.chunk_id = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.null_partition_key = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.producer_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.sequence_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.publish_time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.replicated_from.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.partition_key.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.replicate_to {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.compression {
            my_size += ::protobuf::rt::enum_size(8, v);
        }
        if let Some(v) = self.uncompressed_size {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_messages_in_batch {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_time {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.encryption_keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.encryption_algo.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(ref v) = self.encryption_param.as_ref() {
            my_size += ::protobuf::rt::bytes_size(15, &v);
        }
        if let Some(ref v) = self.schema_version.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        if let Some(v) = self.partition_key_b64_encoded {
            my_size += 3;
        }
        if let Some(ref v) = self.ordering_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(18, &v);
        }
        if let Some(v) = self.deliver_at_time {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.marker_type {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_least_bits {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_most_bits {
            my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.highest_sequence_id {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.null_value {
            my_size += 3;
        }
        if let Some(ref v) = self.uuid.as_ref() {
            my_size += ::protobuf::rt::string_size(26, &v);
        }
        if let Some(v) = self.num_chunks_from_msg {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_chunk_msg_size {
            my_size += ::protobuf::rt::value_size(28, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chunk_id {
            my_size += ::protobuf::rt::value_size(29, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.null_partition_key {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.producer_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.sequence_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.publish_time {
            os.write_uint64(3, v)?;
        }
        for v in &self.properties {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.replicated_from.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.partition_key.as_ref() {
            os.write_string(6, &v)?;
        }
        for v in &self.replicate_to {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.compression {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.uncompressed_size {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.num_messages_in_batch {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.event_time {
            os.write_uint64(12, v)?;
        }
        for v in &self.encryption_keys {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.encryption_algo.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(ref v) = self.encryption_param.as_ref() {
            os.write_bytes(15, &v)?;
        }
        if let Some(ref v) = self.schema_version.as_ref() {
            os.write_bytes(16, &v)?;
        }
        if let Some(v) = self.partition_key_b64_encoded {
            os.write_bool(17, v)?;
        }
        if let Some(ref v) = self.ordering_key.as_ref() {
            os.write_bytes(18, &v)?;
        }
        if let Some(v) = self.deliver_at_time {
            os.write_int64(19, v)?;
        }
        if let Some(v) = self.marker_type {
            os.write_int32(20, v)?;
        }
        if let Some(v) = self.txnid_least_bits {
            os.write_uint64(22, v)?;
        }
        if let Some(v) = self.txnid_most_bits {
            os.write_uint64(23, v)?;
        }
        if let Some(v) = self.highest_sequence_id {
            os.write_uint64(24, v)?;
        }
        if let Some(v) = self.null_value {
            os.write_bool(25, v)?;
        }
        if let Some(ref v) = self.uuid.as_ref() {
            os.write_string(26, &v)?;
        }
        if let Some(v) = self.num_chunks_from_msg {
            os.write_int32(27, v)?;
        }
        if let Some(v) = self.total_chunk_msg_size {
            os.write_int32(28, v)?;
        }
        if let Some(v) = self.chunk_id {
            os.write_int32(29, v)?;
        }
        if let Some(v) = self.null_partition_key {
            os.write_bool(30, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageMetadata {
        MessageMetadata::new()
    }

    fn default_instance() -> &'static MessageMetadata {
        static instance: ::protobuf::rt::LazyV2<MessageMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MessageMetadata::new)
    }
}

impl ::protobuf::Clear for MessageMetadata {
    fn clear(&mut self) {
        self.producer_name.clear();
        self.sequence_id = ::std::option::Option::None;
        self.publish_time = ::std::option::Option::None;
        self.properties.clear();
        self.replicated_from.clear();
        self.partition_key.clear();
        self.replicate_to.clear();
        self.compression = ::std::option::Option::None;
        self.uncompressed_size = ::std::option::Option::None;
        self.num_messages_in_batch = ::std::option::Option::None;
        self.event_time = ::std::option::Option::None;
        self.encryption_keys.clear();
        self.encryption_algo.clear();
        self.encryption_param.clear();
        self.schema_version.clear();
        self.partition_key_b64_encoded = ::std::option::Option::None;
        self.ordering_key.clear();
        self.deliver_at_time = ::std::option::Option::None;
        self.marker_type = ::std::option::Option::None;
        self.txnid_least_bits = ::std::option::Option::None;
        self.txnid_most_bits = ::std::option::Option::None;
        self.highest_sequence_id = ::std::option::Option::None;
        self.null_value = ::std::option::Option::None;
        self.uuid.clear();
        self.num_chunks_from_msg = ::std::option::Option::None;
        self.total_chunk_msg_size = ::std::option::Option::None;
        self.chunk_id = ::std::option::Option::None;
        self.null_partition_key = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleMessageMetadata {
    // message fields
    pub properties: ::protobuf::RepeatedField<KeyValue>,
    partition_key: ::protobuf::SingularField<::std::string::String>,
    payload_size: ::std::option::Option<i32>,
    compacted_out: ::std::option::Option<bool>,
    event_time: ::std::option::Option<u64>,
    partition_key_b64_encoded: ::std::option::Option<bool>,
    ordering_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    sequence_id: ::std::option::Option<u64>,
    null_value: ::std::option::Option<bool>,
    null_partition_key: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleMessageMetadata {
    fn default() -> &'a SingleMessageMetadata {
        <SingleMessageMetadata as ::protobuf::Message>::default_instance()
    }
}

impl SingleMessageMetadata {
    pub fn new() -> SingleMessageMetadata {
        ::std::default::Default::default()
    }

    // repeated .pulsar.proto.KeyValue properties = 1;


    pub fn get_properties(&self) -> &[KeyValue] {
        &self.properties
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<KeyValue>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<KeyValue> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<KeyValue> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }

    // optional string partition_key = 2;


    pub fn get_partition_key(&self) -> &str {
        match self.partition_key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_partition_key(&mut self) {
        self.partition_key.clear();
    }

    pub fn has_partition_key(&self) -> bool {
        self.partition_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition_key(&mut self, v: ::std::string::String) {
        self.partition_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_partition_key(&mut self) -> &mut ::std::string::String {
        if self.partition_key.is_none() {
            self.partition_key.set_default();
        }
        self.partition_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_partition_key(&mut self) -> ::std::string::String {
        self.partition_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int32 payload_size = 3;


    pub fn get_payload_size(&self) -> i32 {
        self.payload_size.unwrap_or(0)
    }
    pub fn clear_payload_size(&mut self) {
        self.payload_size = ::std::option::Option::None;
    }

    pub fn has_payload_size(&self) -> bool {
        self.payload_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload_size(&mut self, v: i32) {
        self.payload_size = ::std::option::Option::Some(v);
    }

    // optional bool compacted_out = 4;


    pub fn get_compacted_out(&self) -> bool {
        self.compacted_out.unwrap_or(false)
    }
    pub fn clear_compacted_out(&mut self) {
        self.compacted_out = ::std::option::Option::None;
    }

    pub fn has_compacted_out(&self) -> bool {
        self.compacted_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compacted_out(&mut self, v: bool) {
        self.compacted_out = ::std::option::Option::Some(v);
    }

    // optional uint64 event_time = 5;


    pub fn get_event_time(&self) -> u64 {
        self.event_time.unwrap_or(0u64)
    }
    pub fn clear_event_time(&mut self) {
        self.event_time = ::std::option::Option::None;
    }

    pub fn has_event_time(&self) -> bool {
        self.event_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_time(&mut self, v: u64) {
        self.event_time = ::std::option::Option::Some(v);
    }

    // optional bool partition_key_b64_encoded = 6;


    pub fn get_partition_key_b64_encoded(&self) -> bool {
        self.partition_key_b64_encoded.unwrap_or(false)
    }
    pub fn clear_partition_key_b64_encoded(&mut self) {
        self.partition_key_b64_encoded = ::std::option::Option::None;
    }

    pub fn has_partition_key_b64_encoded(&self) -> bool {
        self.partition_key_b64_encoded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition_key_b64_encoded(&mut self, v: bool) {
        self.partition_key_b64_encoded = ::std::option::Option::Some(v);
    }

    // optional bytes ordering_key = 7;


    pub fn get_ordering_key(&self) -> &[u8] {
        match self.ordering_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ordering_key(&mut self) {
        self.ordering_key.clear();
    }

    pub fn has_ordering_key(&self) -> bool {
        self.ordering_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordering_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.ordering_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ordering_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ordering_key.is_none() {
            self.ordering_key.set_default();
        }
        self.ordering_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_ordering_key(&mut self) -> ::std::vec::Vec<u8> {
        self.ordering_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 sequence_id = 8;


    pub fn get_sequence_id(&self) -> u64 {
        self.sequence_id.unwrap_or(0)
    }
    pub fn clear_sequence_id(&mut self) {
        self.sequence_id = ::std::option::Option::None;
    }

    pub fn has_sequence_id(&self) -> bool {
        self.sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_id(&mut self, v: u64) {
        self.sequence_id = ::std::option::Option::Some(v);
    }

    // optional bool null_value = 9;


    pub fn get_null_value(&self) -> bool {
        self.null_value.unwrap_or(false)
    }
    pub fn clear_null_value(&mut self) {
        self.null_value = ::std::option::Option::None;
    }

    pub fn has_null_value(&self) -> bool {
        self.null_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_null_value(&mut self, v: bool) {
        self.null_value = ::std::option::Option::Some(v);
    }

    // optional bool null_partition_key = 10;


    pub fn get_null_partition_key(&self) -> bool {
        self.null_partition_key.unwrap_or(false)
    }
    pub fn clear_null_partition_key(&mut self) {
        self.null_partition_key = ::std::option::Option::None;
    }

    pub fn has_null_partition_key(&self) -> bool {
        self.null_partition_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_null_partition_key(&mut self, v: bool) {
        self.null_partition_key = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SingleMessageMetadata {
    fn is_initialized(&self) -> bool {
        if self.payload_size.is_none() {
            return false;
        }
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.partition_key)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.payload_size = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.compacted_out = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.event_time = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.partition_key_b64_encoded = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ordering_key)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence_id = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.null_value = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.null_partition_key = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.partition_key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.payload_size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.compacted_out {
            my_size += 2;
        }
        if let Some(v) = self.event_time {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.partition_key_b64_encoded {
            my_size += 2;
        }
        if let Some(ref v) = self.ordering_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.sequence_id {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.null_value {
            my_size += 2;
        }
        if let Some(v) = self.null_partition_key {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.properties {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.partition_key.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.payload_size {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.compacted_out {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.event_time {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.partition_key_b64_encoded {
            os.write_bool(6, v)?;
        }
        if let Some(ref v) = self.ordering_key.as_ref() {
            os.write_bytes(7, &v)?;
        }
        if let Some(v) = self.sequence_id {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.null_value {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.null_partition_key {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleMessageMetadata {
        SingleMessageMetadata::new()
    }

    fn default_instance() -> &'static SingleMessageMetadata {
        static instance: ::protobuf::rt::LazyV2<SingleMessageMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleMessageMetadata::new)
    }
}

impl ::protobuf::Clear for SingleMessageMetadata {
    fn clear(&mut self) {
        self.properties.clear();
        self.partition_key.clear();
        self.payload_size = ::std::option::Option::None;
        self.compacted_out = ::std::option::Option::None;
        self.event_time = ::std::option::Option::None;
        self.partition_key_b64_encoded = ::std::option::Option::None;
        self.ordering_key.clear();
        self.sequence_id = ::std::option::Option::None;
        self.null_value = ::std::option::Option::None;
        self.null_partition_key = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleMessageMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct BrokerEntryMetadata {
    // message fields
    broker_timestamp: ::std::option::Option<u64>,
    index: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BrokerEntryMetadata {
    fn default() -> &'a BrokerEntryMetadata {
        <BrokerEntryMetadata as ::protobuf::Message>::default_instance()
    }
}

impl BrokerEntryMetadata {
    pub fn new() -> BrokerEntryMetadata {
        ::std::default::Default::default()
    }

    // optional uint64 broker_timestamp = 1;


    pub fn get_broker_timestamp(&self) -> u64 {
        self.broker_timestamp.unwrap_or(0)
    }
    pub fn clear_broker_timestamp(&mut self) {
        self.broker_timestamp = ::std::option::Option::None;
    }

    pub fn has_broker_timestamp(&self) -> bool {
        self.broker_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broker_timestamp(&mut self, v: u64) {
        self.broker_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint64 index = 2;


    pub fn get_index(&self) -> u64 {
        self.index.unwrap_or(0)
    }
    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u64) {
        self.index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BrokerEntryMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.broker_timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.broker_timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.broker_timestamp {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.index {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BrokerEntryMetadata {
        BrokerEntryMetadata::new()
    }

    fn default_instance() -> &'static BrokerEntryMetadata {
        static instance: ::protobuf::rt::LazyV2<BrokerEntryMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BrokerEntryMetadata::new)
    }
}

impl ::protobuf::Clear for BrokerEntryMetadata {
    fn clear(&mut self) {
        self.broker_timestamp = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for BrokerEntryMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandConnect {
    // message fields
    client_version: ::protobuf::SingularField<::std::string::String>,
    auth_method: ::std::option::Option<AuthMethod>,
    auth_method_name: ::protobuf::SingularField<::std::string::String>,
    auth_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    protocol_version: ::std::option::Option<i32>,
    proxy_to_broker_url: ::protobuf::SingularField<::std::string::String>,
    original_principal: ::protobuf::SingularField<::std::string::String>,
    original_auth_data: ::protobuf::SingularField<::std::string::String>,
    original_auth_method: ::protobuf::SingularField<::std::string::String>,
    pub feature_flags: ::protobuf::SingularPtrField<FeatureFlags>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandConnect {
    fn default() -> &'a CommandConnect {
        <CommandConnect as ::protobuf::Message>::default_instance()
    }
}

impl CommandConnect {
    pub fn new() -> CommandConnect {
        ::std::default::Default::default()
    }

    // required string client_version = 1;


    pub fn get_client_version(&self) -> &str {
        match self.client_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_client_version(&mut self) {
        self.client_version.clear();
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: ::std::string::String) {
        self.client_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_version(&mut self) -> &mut ::std::string::String {
        if self.client_version.is_none() {
            self.client_version.set_default();
        }
        self.client_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_version(&mut self) -> ::std::string::String {
        self.client_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .pulsar.proto.AuthMethod auth_method = 2;


    pub fn get_auth_method(&self) -> AuthMethod {
        self.auth_method.unwrap_or(AuthMethod::AuthMethodNone)
    }
    pub fn clear_auth_method(&mut self) {
        self.auth_method = ::std::option::Option::None;
    }

    pub fn has_auth_method(&self) -> bool {
        self.auth_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_method(&mut self, v: AuthMethod) {
        self.auth_method = ::std::option::Option::Some(v);
    }

    // optional string auth_method_name = 5;


    pub fn get_auth_method_name(&self) -> &str {
        match self.auth_method_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_auth_method_name(&mut self) {
        self.auth_method_name.clear();
    }

    pub fn has_auth_method_name(&self) -> bool {
        self.auth_method_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_method_name(&mut self, v: ::std::string::String) {
        self.auth_method_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_method_name(&mut self) -> &mut ::std::string::String {
        if self.auth_method_name.is_none() {
            self.auth_method_name.set_default();
        }
        self.auth_method_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth_method_name(&mut self) -> ::std::string::String {
        self.auth_method_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes auth_data = 3;


    pub fn get_auth_data(&self) -> &[u8] {
        match self.auth_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_auth_data(&mut self) {
        self.auth_data.clear();
    }

    pub fn has_auth_data(&self) -> bool {
        self.auth_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.auth_data.is_none() {
            self.auth_data.set_default();
        }
        self.auth_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth_data(&mut self) -> ::std::vec::Vec<u8> {
        self.auth_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 protocol_version = 4;


    pub fn get_protocol_version(&self) -> i32 {
        self.protocol_version.unwrap_or(0i32)
    }
    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: i32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional string proxy_to_broker_url = 6;


    pub fn get_proxy_to_broker_url(&self) -> &str {
        match self.proxy_to_broker_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_proxy_to_broker_url(&mut self) {
        self.proxy_to_broker_url.clear();
    }

    pub fn has_proxy_to_broker_url(&self) -> bool {
        self.proxy_to_broker_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proxy_to_broker_url(&mut self, v: ::std::string::String) {
        self.proxy_to_broker_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proxy_to_broker_url(&mut self) -> &mut ::std::string::String {
        if self.proxy_to_broker_url.is_none() {
            self.proxy_to_broker_url.set_default();
        }
        self.proxy_to_broker_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_proxy_to_broker_url(&mut self) -> ::std::string::String {
        self.proxy_to_broker_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string original_principal = 7;


    pub fn get_original_principal(&self) -> &str {
        match self.original_principal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_original_principal(&mut self) {
        self.original_principal.clear();
    }

    pub fn has_original_principal(&self) -> bool {
        self.original_principal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_principal(&mut self, v: ::std::string::String) {
        self.original_principal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_principal(&mut self) -> &mut ::std::string::String {
        if self.original_principal.is_none() {
            self.original_principal.set_default();
        }
        self.original_principal.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_principal(&mut self) -> ::std::string::String {
        self.original_principal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string original_auth_data = 8;


    pub fn get_original_auth_data(&self) -> &str {
        match self.original_auth_data.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_original_auth_data(&mut self) {
        self.original_auth_data.clear();
    }

    pub fn has_original_auth_data(&self) -> bool {
        self.original_auth_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_auth_data(&mut self, v: ::std::string::String) {
        self.original_auth_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_auth_data(&mut self) -> &mut ::std::string::String {
        if self.original_auth_data.is_none() {
            self.original_auth_data.set_default();
        }
        self.original_auth_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_auth_data(&mut self) -> ::std::string::String {
        self.original_auth_data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string original_auth_method = 9;


    pub fn get_original_auth_method(&self) -> &str {
        match self.original_auth_method.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_original_auth_method(&mut self) {
        self.original_auth_method.clear();
    }

    pub fn has_original_auth_method(&self) -> bool {
        self.original_auth_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_auth_method(&mut self, v: ::std::string::String) {
        self.original_auth_method = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_auth_method(&mut self) -> &mut ::std::string::String {
        if self.original_auth_method.is_none() {
            self.original_auth_method.set_default();
        }
        self.original_auth_method.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_auth_method(&mut self) -> ::std::string::String {
        self.original_auth_method.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .pulsar.proto.FeatureFlags feature_flags = 10;


    pub fn get_feature_flags(&self) -> &FeatureFlags {
        self.feature_flags.as_ref().unwrap_or_else(|| <FeatureFlags as ::protobuf::Message>::default_instance())
    }
    pub fn clear_feature_flags(&mut self) {
        self.feature_flags.clear();
    }

    pub fn has_feature_flags(&self) -> bool {
        self.feature_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feature_flags(&mut self, v: FeatureFlags) {
        self.feature_flags = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feature_flags(&mut self) -> &mut FeatureFlags {
        if self.feature_flags.is_none() {
            self.feature_flags.set_default();
        }
        self.feature_flags.as_mut().unwrap()
    }

    // Take field
    pub fn take_feature_flags(&mut self) -> FeatureFlags {
        self.feature_flags.take().unwrap_or_else(|| FeatureFlags::new())
    }
}

impl ::protobuf::Message for CommandConnect {
    fn is_initialized(&self) -> bool {
        if self.client_version.is_none() {
            return false;
        }
        for v in &self.feature_flags {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.client_version)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.auth_method, 2, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.auth_method_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.auth_data)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.proxy_to_broker_url)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.original_principal)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.original_auth_data)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.original_auth_method)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.feature_flags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.client_version.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.auth_method {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.auth_method_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.auth_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.proxy_to_broker_url.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.original_principal.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.original_auth_data.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.original_auth_method.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.feature_flags.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.client_version.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.auth_method {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.auth_method_name.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.auth_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.proxy_to_broker_url.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.original_principal.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.original_auth_data.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.original_auth_method.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.feature_flags.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandConnect {
        CommandConnect::new()
    }

    fn default_instance() -> &'static CommandConnect {
        static instance: ::protobuf::rt::LazyV2<CommandConnect> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandConnect::new)
    }
}

impl ::protobuf::Clear for CommandConnect {
    fn clear(&mut self) {
        self.client_version.clear();
        self.auth_method = ::std::option::Option::None;
        self.auth_method_name.clear();
        self.auth_data.clear();
        self.protocol_version = ::std::option::Option::None;
        self.proxy_to_broker_url.clear();
        self.original_principal.clear();
        self.original_auth_data.clear();
        self.original_auth_method.clear();
        self.feature_flags.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandConnect {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FeatureFlags {
    // message fields
    supports_auth_refresh: ::std::option::Option<bool>,
    supports_broker_entry_metadata: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeatureFlags {
    fn default() -> &'a FeatureFlags {
        <FeatureFlags as ::protobuf::Message>::default_instance()
    }
}

impl FeatureFlags {
    pub fn new() -> FeatureFlags {
        ::std::default::Default::default()
    }

    // optional bool supports_auth_refresh = 1;


    pub fn get_supports_auth_refresh(&self) -> bool {
        self.supports_auth_refresh.unwrap_or(false)
    }
    pub fn clear_supports_auth_refresh(&mut self) {
        self.supports_auth_refresh = ::std::option::Option::None;
    }

    pub fn has_supports_auth_refresh(&self) -> bool {
        self.supports_auth_refresh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supports_auth_refresh(&mut self, v: bool) {
        self.supports_auth_refresh = ::std::option::Option::Some(v);
    }

    // optional bool supports_broker_entry_metadata = 2;


    pub fn get_supports_broker_entry_metadata(&self) -> bool {
        self.supports_broker_entry_metadata.unwrap_or(false)
    }
    pub fn clear_supports_broker_entry_metadata(&mut self) {
        self.supports_broker_entry_metadata = ::std::option::Option::None;
    }

    pub fn has_supports_broker_entry_metadata(&self) -> bool {
        self.supports_broker_entry_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supports_broker_entry_metadata(&mut self, v: bool) {
        self.supports_broker_entry_metadata = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for FeatureFlags {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_auth_refresh = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_broker_entry_metadata = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.supports_auth_refresh {
            my_size += 2;
        }
        if let Some(v) = self.supports_broker_entry_metadata {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.supports_auth_refresh {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.supports_broker_entry_metadata {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureFlags {
        FeatureFlags::new()
    }

    fn default_instance() -> &'static FeatureFlags {
        static instance: ::protobuf::rt::LazyV2<FeatureFlags> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeatureFlags::new)
    }
}

impl ::protobuf::Clear for FeatureFlags {
    fn clear(&mut self) {
        self.supports_auth_refresh = ::std::option::Option::None;
        self.supports_broker_entry_metadata = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureFlags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandConnected {
    // message fields
    server_version: ::protobuf::SingularField<::std::string::String>,
    protocol_version: ::std::option::Option<i32>,
    max_message_size: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandConnected {
    fn default() -> &'a CommandConnected {
        <CommandConnected as ::protobuf::Message>::default_instance()
    }
}

impl CommandConnected {
    pub fn new() -> CommandConnected {
        ::std::default::Default::default()
    }

    // required string server_version = 1;


    pub fn get_server_version(&self) -> &str {
        match self.server_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_server_version(&mut self) {
        self.server_version.clear();
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: ::std::string::String) {
        self.server_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_version(&mut self) -> &mut ::std::string::String {
        if self.server_version.is_none() {
            self.server_version.set_default();
        }
        self.server_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_version(&mut self) -> ::std::string::String {
        self.server_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 protocol_version = 2;


    pub fn get_protocol_version(&self) -> i32 {
        self.protocol_version.unwrap_or(0i32)
    }
    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: i32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional int32 max_message_size = 3;


    pub fn get_max_message_size(&self) -> i32 {
        self.max_message_size.unwrap_or(0)
    }
    pub fn clear_max_message_size(&mut self) {
        self.max_message_size = ::std::option::Option::None;
    }

    pub fn has_max_message_size(&self) -> bool {
        self.max_message_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_message_size(&mut self, v: i32) {
        self.max_message_size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandConnected {
    fn is_initialized(&self) -> bool {
        if self.server_version.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.server_version)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_message_size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server_version.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_message_size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server_version.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.max_message_size {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandConnected {
        CommandConnected::new()
    }

    fn default_instance() -> &'static CommandConnected {
        static instance: ::protobuf::rt::LazyV2<CommandConnected> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandConnected::new)
    }
}

impl ::protobuf::Clear for CommandConnected {
    fn clear(&mut self) {
        self.server_version.clear();
        self.protocol_version = ::std::option::Option::None;
        self.max_message_size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandConnected {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandAuthResponse {
    // message fields
    client_version: ::protobuf::SingularField<::std::string::String>,
    pub response: ::protobuf::SingularPtrField<AuthData>,
    protocol_version: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandAuthResponse {
    fn default() -> &'a CommandAuthResponse {
        <CommandAuthResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommandAuthResponse {
    pub fn new() -> CommandAuthResponse {
        ::std::default::Default::default()
    }

    // optional string client_version = 1;


    pub fn get_client_version(&self) -> &str {
        match self.client_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_client_version(&mut self) {
        self.client_version.clear();
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: ::std::string::String) {
        self.client_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_version(&mut self) -> &mut ::std::string::String {
        if self.client_version.is_none() {
            self.client_version.set_default();
        }
        self.client_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_version(&mut self) -> ::std::string::String {
        self.client_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .pulsar.proto.AuthData response = 2;


    pub fn get_response(&self) -> &AuthData {
        self.response.as_ref().unwrap_or_else(|| <AuthData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_response(&mut self) {
        self.response.clear();
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: AuthData) {
        self.response = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response(&mut self) -> &mut AuthData {
        if self.response.is_none() {
            self.response.set_default();
        }
        self.response.as_mut().unwrap()
    }

    // Take field
    pub fn take_response(&mut self) -> AuthData {
        self.response.take().unwrap_or_else(|| AuthData::new())
    }

    // optional int32 protocol_version = 3;


    pub fn get_protocol_version(&self) -> i32 {
        self.protocol_version.unwrap_or(0i32)
    }
    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: i32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandAuthResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.client_version)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.response)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.client_version.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.client_version.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.response.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandAuthResponse {
        CommandAuthResponse::new()
    }

    fn default_instance() -> &'static CommandAuthResponse {
        static instance: ::protobuf::rt::LazyV2<CommandAuthResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandAuthResponse::new)
    }
}

impl ::protobuf::Clear for CommandAuthResponse {
    fn clear(&mut self) {
        self.client_version.clear();
        self.response.clear();
        self.protocol_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandAuthResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandAuthChallenge {
    // message fields
    server_version: ::protobuf::SingularField<::std::string::String>,
    pub challenge: ::protobuf::SingularPtrField<AuthData>,
    protocol_version: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandAuthChallenge {
    fn default() -> &'a CommandAuthChallenge {
        <CommandAuthChallenge as ::protobuf::Message>::default_instance()
    }
}

impl CommandAuthChallenge {
    pub fn new() -> CommandAuthChallenge {
        ::std::default::Default::default()
    }

    // optional string server_version = 1;


    pub fn get_server_version(&self) -> &str {
        match self.server_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_server_version(&mut self) {
        self.server_version.clear();
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: ::std::string::String) {
        self.server_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_version(&mut self) -> &mut ::std::string::String {
        if self.server_version.is_none() {
            self.server_version.set_default();
        }
        self.server_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_version(&mut self) -> ::std::string::String {
        self.server_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .pulsar.proto.AuthData challenge = 2;


    pub fn get_challenge(&self) -> &AuthData {
        self.challenge.as_ref().unwrap_or_else(|| <AuthData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_challenge(&mut self) {
        self.challenge.clear();
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: AuthData) {
        self.challenge = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_challenge(&mut self) -> &mut AuthData {
        if self.challenge.is_none() {
            self.challenge.set_default();
        }
        self.challenge.as_mut().unwrap()
    }

    // Take field
    pub fn take_challenge(&mut self) -> AuthData {
        self.challenge.take().unwrap_or_else(|| AuthData::new())
    }

    // optional int32 protocol_version = 3;


    pub fn get_protocol_version(&self) -> i32 {
        self.protocol_version.unwrap_or(0i32)
    }
    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: i32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandAuthChallenge {
    fn is_initialized(&self) -> bool {
        for v in &self.challenge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.server_version)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.challenge)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server_version.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.challenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server_version.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.challenge.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandAuthChallenge {
        CommandAuthChallenge::new()
    }

    fn default_instance() -> &'static CommandAuthChallenge {
        static instance: ::protobuf::rt::LazyV2<CommandAuthChallenge> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandAuthChallenge::new)
    }
}

impl ::protobuf::Clear for CommandAuthChallenge {
    fn clear(&mut self) {
        self.server_version.clear();
        self.challenge.clear();
        self.protocol_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandAuthChallenge {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AuthData {
    // message fields
    auth_method_name: ::protobuf::SingularField<::std::string::String>,
    auth_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthData {
    fn default() -> &'a AuthData {
        <AuthData as ::protobuf::Message>::default_instance()
    }
}

impl AuthData {
    pub fn new() -> AuthData {
        ::std::default::Default::default()
    }

    // optional string auth_method_name = 1;


    pub fn get_auth_method_name(&self) -> &str {
        match self.auth_method_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_auth_method_name(&mut self) {
        self.auth_method_name.clear();
    }

    pub fn has_auth_method_name(&self) -> bool {
        self.auth_method_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_method_name(&mut self, v: ::std::string::String) {
        self.auth_method_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_method_name(&mut self) -> &mut ::std::string::String {
        if self.auth_method_name.is_none() {
            self.auth_method_name.set_default();
        }
        self.auth_method_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth_method_name(&mut self) -> ::std::string::String {
        self.auth_method_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes auth_data = 2;


    pub fn get_auth_data(&self) -> &[u8] {
        match self.auth_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_auth_data(&mut self) {
        self.auth_data.clear();
    }

    pub fn has_auth_data(&self) -> bool {
        self.auth_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.auth_data.is_none() {
            self.auth_data.set_default();
        }
        self.auth_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth_data(&mut self) -> ::std::vec::Vec<u8> {
        self.auth_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for AuthData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.auth_method_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.auth_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.auth_method_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.auth_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.auth_method_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.auth_data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthData {
        AuthData::new()
    }

    fn default_instance() -> &'static AuthData {
        static instance: ::protobuf::rt::LazyV2<AuthData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthData::new)
    }
}

impl ::protobuf::Clear for AuthData {
    fn clear(&mut self) {
        self.auth_method_name.clear();
        self.auth_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct KeySharedMeta {
    // message fields
    keySharedMode: ::std::option::Option<KeySharedMode>,
    pub hashRanges: ::protobuf::RepeatedField<IntRange>,
    allowOutOfOrderDelivery: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeySharedMeta {
    fn default() -> &'a KeySharedMeta {
        <KeySharedMeta as ::protobuf::Message>::default_instance()
    }
}

impl KeySharedMeta {
    pub fn new() -> KeySharedMeta {
        ::std::default::Default::default()
    }

    // required .pulsar.proto.KeySharedMode keySharedMode = 1;


    pub fn get_keySharedMode(&self) -> KeySharedMode {
        self.keySharedMode.unwrap_or(KeySharedMode::AUTO_SPLIT)
    }
    pub fn clear_keySharedMode(&mut self) {
        self.keySharedMode = ::std::option::Option::None;
    }

    pub fn has_keySharedMode(&self) -> bool {
        self.keySharedMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keySharedMode(&mut self, v: KeySharedMode) {
        self.keySharedMode = ::std::option::Option::Some(v);
    }

    // repeated .pulsar.proto.IntRange hashRanges = 3;


    pub fn get_hashRanges(&self) -> &[IntRange] {
        &self.hashRanges
    }
    pub fn clear_hashRanges(&mut self) {
        self.hashRanges.clear();
    }

    // Param is passed by value, moved
    pub fn set_hashRanges(&mut self, v: ::protobuf::RepeatedField<IntRange>) {
        self.hashRanges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hashRanges(&mut self) -> &mut ::protobuf::RepeatedField<IntRange> {
        &mut self.hashRanges
    }

    // Take field
    pub fn take_hashRanges(&mut self) -> ::protobuf::RepeatedField<IntRange> {
        ::std::mem::replace(&mut self.hashRanges, ::protobuf::RepeatedField::new())
    }

    // optional bool allowOutOfOrderDelivery = 4;


    pub fn get_allowOutOfOrderDelivery(&self) -> bool {
        self.allowOutOfOrderDelivery.unwrap_or(false)
    }
    pub fn clear_allowOutOfOrderDelivery(&mut self) {
        self.allowOutOfOrderDelivery = ::std::option::Option::None;
    }

    pub fn has_allowOutOfOrderDelivery(&self) -> bool {
        self.allowOutOfOrderDelivery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allowOutOfOrderDelivery(&mut self, v: bool) {
        self.allowOutOfOrderDelivery = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for KeySharedMeta {
    fn is_initialized(&self) -> bool {
        if self.keySharedMode.is_none() {
            return false;
        }
        for v in &self.hashRanges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.keySharedMode, 1, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hashRanges)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allowOutOfOrderDelivery = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.keySharedMode {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.hashRanges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.allowOutOfOrderDelivery {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.keySharedMode {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.hashRanges {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.allowOutOfOrderDelivery {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeySharedMeta {
        KeySharedMeta::new()
    }

    fn default_instance() -> &'static KeySharedMeta {
        static instance: ::protobuf::rt::LazyV2<KeySharedMeta> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeySharedMeta::new)
    }
}

impl ::protobuf::Clear for KeySharedMeta {
    fn clear(&mut self) {
        self.keySharedMode = ::std::option::Option::None;
        self.hashRanges.clear();
        self.allowOutOfOrderDelivery = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for KeySharedMeta {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandSubscribe {
    // message fields
    topic: ::protobuf::SingularField<::std::string::String>,
    subscription: ::protobuf::SingularField<::std::string::String>,
    subType: ::std::option::Option<CommandSubscribe_SubType>,
    consumer_id: ::std::option::Option<u64>,
    request_id: ::std::option::Option<u64>,
    consumer_name: ::protobuf::SingularField<::std::string::String>,
    priority_level: ::std::option::Option<i32>,
    durable: ::std::option::Option<bool>,
    pub start_message_id: ::protobuf::SingularPtrField<MessageIdData>,
    pub metadata: ::protobuf::RepeatedField<KeyValue>,
    read_compacted: ::std::option::Option<bool>,
    pub schema: ::protobuf::SingularPtrField<Schema>,
    initialPosition: ::std::option::Option<CommandSubscribe_InitialPosition>,
    replicate_subscription_state: ::std::option::Option<bool>,
    force_topic_creation: ::std::option::Option<bool>,
    start_message_rollback_duration_sec: ::std::option::Option<u64>,
    pub keySharedMeta: ::protobuf::SingularPtrField<KeySharedMeta>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandSubscribe {
    fn default() -> &'a CommandSubscribe {
        <CommandSubscribe as ::protobuf::Message>::default_instance()
    }
}

impl CommandSubscribe {
    pub fn new() -> CommandSubscribe {
        ::std::default::Default::default()
    }

    // required string topic = 1;


    pub fn get_topic(&self) -> &str {
        match self.topic.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    pub fn has_topic(&self) -> bool {
        self.topic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        if self.topic.is_none() {
            self.topic.set_default();
        }
        self.topic.as_mut().unwrap()
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        self.topic.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string subscription = 2;


    pub fn get_subscription(&self) -> &str {
        match self.subscription.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    pub fn has_subscription(&self) -> bool {
        self.subscription.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: ::std::string::String) {
        self.subscription = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut ::std::string::String {
        if self.subscription.is_none() {
            self.subscription.set_default();
        }
        self.subscription.as_mut().unwrap()
    }

    // Take field
    pub fn take_subscription(&mut self) -> ::std::string::String {
        self.subscription.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .pulsar.proto.CommandSubscribe.SubType subType = 3;


    pub fn get_subType(&self) -> CommandSubscribe_SubType {
        self.subType.unwrap_or(CommandSubscribe_SubType::Exclusive)
    }
    pub fn clear_subType(&mut self) {
        self.subType = ::std::option::Option::None;
    }

    pub fn has_subType(&self) -> bool {
        self.subType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subType(&mut self, v: CommandSubscribe_SubType) {
        self.subType = ::std::option::Option::Some(v);
    }

    // required uint64 consumer_id = 4;


    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }
    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }

    // required uint64 request_id = 5;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional string consumer_name = 6;


    pub fn get_consumer_name(&self) -> &str {
        match self.consumer_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_consumer_name(&mut self) {
        self.consumer_name.clear();
    }

    pub fn has_consumer_name(&self) -> bool {
        self.consumer_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_name(&mut self, v: ::std::string::String) {
        self.consumer_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumer_name(&mut self) -> &mut ::std::string::String {
        if self.consumer_name.is_none() {
            self.consumer_name.set_default();
        }
        self.consumer_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_consumer_name(&mut self) -> ::std::string::String {
        self.consumer_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 priority_level = 7;


    pub fn get_priority_level(&self) -> i32 {
        self.priority_level.unwrap_or(0)
    }
    pub fn clear_priority_level(&mut self) {
        self.priority_level = ::std::option::Option::None;
    }

    pub fn has_priority_level(&self) -> bool {
        self.priority_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority_level(&mut self, v: i32) {
        self.priority_level = ::std::option::Option::Some(v);
    }

    // optional bool durable = 8;


    pub fn get_durable(&self) -> bool {
        self.durable.unwrap_or(true)
    }
    pub fn clear_durable(&mut self) {
        self.durable = ::std::option::Option::None;
    }

    pub fn has_durable(&self) -> bool {
        self.durable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_durable(&mut self, v: bool) {
        self.durable = ::std::option::Option::Some(v);
    }

    // optional .pulsar.proto.MessageIdData start_message_id = 9;


    pub fn get_start_message_id(&self) -> &MessageIdData {
        self.start_message_id.as_ref().unwrap_or_else(|| <MessageIdData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_start_message_id(&mut self) {
        self.start_message_id.clear();
    }

    pub fn has_start_message_id(&self) -> bool {
        self.start_message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_message_id(&mut self, v: MessageIdData) {
        self.start_message_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_message_id(&mut self) -> &mut MessageIdData {
        if self.start_message_id.is_none() {
            self.start_message_id.set_default();
        }
        self.start_message_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_message_id(&mut self) -> MessageIdData {
        self.start_message_id.take().unwrap_or_else(|| MessageIdData::new())
    }

    // repeated .pulsar.proto.KeyValue metadata = 10;


    pub fn get_metadata(&self) -> &[KeyValue] {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::RepeatedField<KeyValue>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::RepeatedField<KeyValue> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::RepeatedField<KeyValue> {
        ::std::mem::replace(&mut self.metadata, ::protobuf::RepeatedField::new())
    }

    // optional bool read_compacted = 11;


    pub fn get_read_compacted(&self) -> bool {
        self.read_compacted.unwrap_or(false)
    }
    pub fn clear_read_compacted(&mut self) {
        self.read_compacted = ::std::option::Option::None;
    }

    pub fn has_read_compacted(&self) -> bool {
        self.read_compacted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_compacted(&mut self, v: bool) {
        self.read_compacted = ::std::option::Option::Some(v);
    }

    // optional .pulsar.proto.Schema schema = 12;


    pub fn get_schema(&self) -> &Schema {
        self.schema.as_ref().unwrap_or_else(|| <Schema as ::protobuf::Message>::default_instance())
    }
    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: Schema) {
        self.schema = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut Schema {
        if self.schema.is_none() {
            self.schema.set_default();
        }
        self.schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema(&mut self) -> Schema {
        self.schema.take().unwrap_or_else(|| Schema::new())
    }

    // optional .pulsar.proto.CommandSubscribe.InitialPosition initialPosition = 13;


    pub fn get_initialPosition(&self) -> CommandSubscribe_InitialPosition {
        self.initialPosition.unwrap_or(CommandSubscribe_InitialPosition::Latest)
    }
    pub fn clear_initialPosition(&mut self) {
        self.initialPosition = ::std::option::Option::None;
    }

    pub fn has_initialPosition(&self) -> bool {
        self.initialPosition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initialPosition(&mut self, v: CommandSubscribe_InitialPosition) {
        self.initialPosition = ::std::option::Option::Some(v);
    }

    // optional bool replicate_subscription_state = 14;


    pub fn get_replicate_subscription_state(&self) -> bool {
        self.replicate_subscription_state.unwrap_or(false)
    }
    pub fn clear_replicate_subscription_state(&mut self) {
        self.replicate_subscription_state = ::std::option::Option::None;
    }

    pub fn has_replicate_subscription_state(&self) -> bool {
        self.replicate_subscription_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicate_subscription_state(&mut self, v: bool) {
        self.replicate_subscription_state = ::std::option::Option::Some(v);
    }

    // optional bool force_topic_creation = 15;


    pub fn get_force_topic_creation(&self) -> bool {
        self.force_topic_creation.unwrap_or(true)
    }
    pub fn clear_force_topic_creation(&mut self) {
        self.force_topic_creation = ::std::option::Option::None;
    }

    pub fn has_force_topic_creation(&self) -> bool {
        self.force_topic_creation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_topic_creation(&mut self, v: bool) {
        self.force_topic_creation = ::std::option::Option::Some(v);
    }

    // optional uint64 start_message_rollback_duration_sec = 16;


    pub fn get_start_message_rollback_duration_sec(&self) -> u64 {
        self.start_message_rollback_duration_sec.unwrap_or(0u64)
    }
    pub fn clear_start_message_rollback_duration_sec(&mut self) {
        self.start_message_rollback_duration_sec = ::std::option::Option::None;
    }

    pub fn has_start_message_rollback_duration_sec(&self) -> bool {
        self.start_message_rollback_duration_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_message_rollback_duration_sec(&mut self, v: u64) {
        self.start_message_rollback_duration_sec = ::std::option::Option::Some(v);
    }

    // optional .pulsar.proto.KeySharedMeta keySharedMeta = 17;


    pub fn get_keySharedMeta(&self) -> &KeySharedMeta {
        self.keySharedMeta.as_ref().unwrap_or_else(|| <KeySharedMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_keySharedMeta(&mut self) {
        self.keySharedMeta.clear();
    }

    pub fn has_keySharedMeta(&self) -> bool {
        self.keySharedMeta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keySharedMeta(&mut self, v: KeySharedMeta) {
        self.keySharedMeta = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keySharedMeta(&mut self) -> &mut KeySharedMeta {
        if self.keySharedMeta.is_none() {
            self.keySharedMeta.set_default();
        }
        self.keySharedMeta.as_mut().unwrap()
    }

    // Take field
    pub fn take_keySharedMeta(&mut self) -> KeySharedMeta {
        self.keySharedMeta.take().unwrap_or_else(|| KeySharedMeta::new())
    }
}

impl ::protobuf::Message for CommandSubscribe {
    fn is_initialized(&self) -> bool {
        if self.topic.is_none() {
            return false;
        }
        if self.subscription.is_none() {
            return false;
        }
        if self.subType.is_none() {
            return false;
        }
        if self.consumer_id.is_none() {
            return false;
        }
        if self.request_id.is_none() {
            return false;
        }
        for v in &self.start_message_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.schema {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.keySharedMeta {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.topic)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subscription)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.subType, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.consumer_name)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.priority_level = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.durable = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start_message_id)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metadata)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.read_compacted = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.schema)?;
                },
                13 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.initialPosition, 13, &mut self.unknown_fields)?
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.replicate_subscription_state = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force_topic_creation = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_message_rollback_duration_sec = ::std::option::Option::Some(tmp);
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.keySharedMeta)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.topic.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.subscription.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.subType {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.consumer_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.priority_level {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.durable {
            my_size += 2;
        }
        if let Some(ref v) = self.start_message_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.metadata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.read_compacted {
            my_size += 2;
        }
        if let Some(ref v) = self.schema.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.initialPosition {
            my_size += ::protobuf::rt::enum_size(13, v);
        }
        if let Some(v) = self.replicate_subscription_state {
            my_size += 2;
        }
        if let Some(v) = self.force_topic_creation {
            my_size += 2;
        }
        if let Some(v) = self.start_message_rollback_duration_sec {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.keySharedMeta.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.topic.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.subscription.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.subType {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.consumer_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(5, v)?;
        }
        if let Some(ref v) = self.consumer_name.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.priority_level {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.durable {
            os.write_bool(8, v)?;
        }
        if let Some(ref v) = self.start_message_id.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.metadata {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.read_compacted {
            os.write_bool(11, v)?;
        }
        if let Some(ref v) = self.schema.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.initialPosition {
            os.write_enum(13, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.replicate_subscription_state {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.force_topic_creation {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.start_message_rollback_duration_sec {
            os.write_uint64(16, v)?;
        }
        if let Some(ref v) = self.keySharedMeta.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandSubscribe {
        CommandSubscribe::new()
    }

    fn default_instance() -> &'static CommandSubscribe {
        static instance: ::protobuf::rt::LazyV2<CommandSubscribe> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandSubscribe::new)
    }
}

impl ::protobuf::Clear for CommandSubscribe {
    fn clear(&mut self) {
        self.topic.clear();
        self.subscription.clear();
        self.subType = ::std::option::Option::None;
        self.consumer_id = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.consumer_name.clear();
        self.priority_level = ::std::option::Option::None;
        self.durable = ::std::option::Option::None;
        self.start_message_id.clear();
        self.metadata.clear();
        self.read_compacted = ::std::option::Option::None;
        self.schema.clear();
        self.initialPosition = ::std::option::Option::None;
        self.replicate_subscription_state = ::std::option::Option::None;
        self.force_topic_creation = ::std::option::Option::None;
        self.start_message_rollback_duration_sec = ::std::option::Option::None;
        self.keySharedMeta.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandSubscribe {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommandSubscribe_SubType {
    Exclusive = 0,
    Shared = 1,
    Failover = 2,
    Key_Shared = 3,
}

impl ::protobuf::ProtobufEnum for CommandSubscribe_SubType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommandSubscribe_SubType> {
        match value {
            0 => ::std::option::Option::Some(CommandSubscribe_SubType::Exclusive),
            1 => ::std::option::Option::Some(CommandSubscribe_SubType::Shared),
            2 => ::std::option::Option::Some(CommandSubscribe_SubType::Failover),
            3 => ::std::option::Option::Some(CommandSubscribe_SubType::Key_Shared),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommandSubscribe_SubType] = &[
            CommandSubscribe_SubType::Exclusive,
            CommandSubscribe_SubType::Shared,
            CommandSubscribe_SubType::Failover,
            CommandSubscribe_SubType::Key_Shared,
        ];
        values
    }
}

impl ::std::marker::Copy for CommandSubscribe_SubType {
}

impl ::std::default::Default for CommandSubscribe_SubType {
    fn default() -> Self {
        CommandSubscribe_SubType::Exclusive
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandSubscribe_SubType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommandSubscribe_InitialPosition {
    Latest = 0,
    Earliest = 1,
}

impl ::protobuf::ProtobufEnum for CommandSubscribe_InitialPosition {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommandSubscribe_InitialPosition> {
        match value {
            0 => ::std::option::Option::Some(CommandSubscribe_InitialPosition::Latest),
            1 => ::std::option::Option::Some(CommandSubscribe_InitialPosition::Earliest),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommandSubscribe_InitialPosition] = &[
            CommandSubscribe_InitialPosition::Latest,
            CommandSubscribe_InitialPosition::Earliest,
        ];
        values
    }
}

impl ::std::marker::Copy for CommandSubscribe_InitialPosition {
}

impl ::std::default::Default for CommandSubscribe_InitialPosition {
    fn default() -> Self {
        CommandSubscribe_InitialPosition::Latest
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandSubscribe_InitialPosition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandPartitionedTopicMetadata {
    // message fields
    topic: ::protobuf::SingularField<::std::string::String>,
    request_id: ::std::option::Option<u64>,
    original_principal: ::protobuf::SingularField<::std::string::String>,
    original_auth_data: ::protobuf::SingularField<::std::string::String>,
    original_auth_method: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandPartitionedTopicMetadata {
    fn default() -> &'a CommandPartitionedTopicMetadata {
        <CommandPartitionedTopicMetadata as ::protobuf::Message>::default_instance()
    }
}

impl CommandPartitionedTopicMetadata {
    pub fn new() -> CommandPartitionedTopicMetadata {
        ::std::default::Default::default()
    }

    // required string topic = 1;


    pub fn get_topic(&self) -> &str {
        match self.topic.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    pub fn has_topic(&self) -> bool {
        self.topic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        if self.topic.is_none() {
            self.topic.set_default();
        }
        self.topic.as_mut().unwrap()
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        self.topic.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 request_id = 2;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional string original_principal = 3;


    pub fn get_original_principal(&self) -> &str {
        match self.original_principal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_original_principal(&mut self) {
        self.original_principal.clear();
    }

    pub fn has_original_principal(&self) -> bool {
        self.original_principal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_principal(&mut self, v: ::std::string::String) {
        self.original_principal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_principal(&mut self) -> &mut ::std::string::String {
        if self.original_principal.is_none() {
            self.original_principal.set_default();
        }
        self.original_principal.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_principal(&mut self) -> ::std::string::String {
        self.original_principal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string original_auth_data = 4;


    pub fn get_original_auth_data(&self) -> &str {
        match self.original_auth_data.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_original_auth_data(&mut self) {
        self.original_auth_data.clear();
    }

    pub fn has_original_auth_data(&self) -> bool {
        self.original_auth_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_auth_data(&mut self, v: ::std::string::String) {
        self.original_auth_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_auth_data(&mut self) -> &mut ::std::string::String {
        if self.original_auth_data.is_none() {
            self.original_auth_data.set_default();
        }
        self.original_auth_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_auth_data(&mut self) -> ::std::string::String {
        self.original_auth_data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string original_auth_method = 5;


    pub fn get_original_auth_method(&self) -> &str {
        match self.original_auth_method.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_original_auth_method(&mut self) {
        self.original_auth_method.clear();
    }

    pub fn has_original_auth_method(&self) -> bool {
        self.original_auth_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_auth_method(&mut self, v: ::std::string::String) {
        self.original_auth_method = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_auth_method(&mut self) -> &mut ::std::string::String {
        if self.original_auth_method.is_none() {
            self.original_auth_method.set_default();
        }
        self.original_auth_method.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_auth_method(&mut self) -> ::std::string::String {
        self.original_auth_method.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CommandPartitionedTopicMetadata {
    fn is_initialized(&self) -> bool {
        if self.topic.is_none() {
            return false;
        }
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.topic)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.original_principal)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.original_auth_data)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.original_auth_method)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.topic.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.original_principal.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.original_auth_data.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.original_auth_method.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.topic.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.original_principal.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.original_auth_data.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.original_auth_method.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandPartitionedTopicMetadata {
        CommandPartitionedTopicMetadata::new()
    }

    fn default_instance() -> &'static CommandPartitionedTopicMetadata {
        static instance: ::protobuf::rt::LazyV2<CommandPartitionedTopicMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandPartitionedTopicMetadata::new)
    }
}

impl ::protobuf::Clear for CommandPartitionedTopicMetadata {
    fn clear(&mut self) {
        self.topic.clear();
        self.request_id = ::std::option::Option::None;
        self.original_principal.clear();
        self.original_auth_data.clear();
        self.original_auth_method.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandPartitionedTopicMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandPartitionedTopicMetadataResponse {
    // message fields
    partitions: ::std::option::Option<u32>,
    request_id: ::std::option::Option<u64>,
    response: ::std::option::Option<CommandPartitionedTopicMetadataResponse_LookupType>,
    error: ::std::option::Option<ServerError>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandPartitionedTopicMetadataResponse {
    fn default() -> &'a CommandPartitionedTopicMetadataResponse {
        <CommandPartitionedTopicMetadataResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommandPartitionedTopicMetadataResponse {
    pub fn new() -> CommandPartitionedTopicMetadataResponse {
        ::std::default::Default::default()
    }

    // optional uint32 partitions = 1;


    pub fn get_partitions(&self) -> u32 {
        self.partitions.unwrap_or(0)
    }
    pub fn clear_partitions(&mut self) {
        self.partitions = ::std::option::Option::None;
    }

    pub fn has_partitions(&self) -> bool {
        self.partitions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partitions(&mut self, v: u32) {
        self.partitions = ::std::option::Option::Some(v);
    }

    // required uint64 request_id = 2;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse.LookupType response = 3;


    pub fn get_response(&self) -> CommandPartitionedTopicMetadataResponse_LookupType {
        self.response.unwrap_or(CommandPartitionedTopicMetadataResponse_LookupType::Success)
    }
    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: CommandPartitionedTopicMetadataResponse_LookupType) {
        self.response = ::std::option::Option::Some(v);
    }

    // optional .pulsar.proto.ServerError error = 4;


    pub fn get_error(&self) -> ServerError {
        self.error.unwrap_or(ServerError::UnknownError)
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ServerError) {
        self.error = ::std::option::Option::Some(v);
    }

    // optional string message = 5;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CommandPartitionedTopicMetadataResponse {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.partitions = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.response, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.partitions {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.partitions {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.response {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.error {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandPartitionedTopicMetadataResponse {
        CommandPartitionedTopicMetadataResponse::new()
    }

    fn default_instance() -> &'static CommandPartitionedTopicMetadataResponse {
        static instance: ::protobuf::rt::LazyV2<CommandPartitionedTopicMetadataResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandPartitionedTopicMetadataResponse::new)
    }
}

impl ::protobuf::Clear for CommandPartitionedTopicMetadataResponse {
    fn clear(&mut self) {
        self.partitions = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandPartitionedTopicMetadataResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommandPartitionedTopicMetadataResponse_LookupType {
    Success = 0,
    Failed = 1,
}

impl ::protobuf::ProtobufEnum for CommandPartitionedTopicMetadataResponse_LookupType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommandPartitionedTopicMetadataResponse_LookupType> {
        match value {
            0 => ::std::option::Option::Some(CommandPartitionedTopicMetadataResponse_LookupType::Success),
            1 => ::std::option::Option::Some(CommandPartitionedTopicMetadataResponse_LookupType::Failed),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommandPartitionedTopicMetadataResponse_LookupType] = &[
            CommandPartitionedTopicMetadataResponse_LookupType::Success,
            CommandPartitionedTopicMetadataResponse_LookupType::Failed,
        ];
        values
    }
}

impl ::std::marker::Copy for CommandPartitionedTopicMetadataResponse_LookupType {
}

impl ::std::default::Default for CommandPartitionedTopicMetadataResponse_LookupType {
    fn default() -> Self {
        CommandPartitionedTopicMetadataResponse_LookupType::Success
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandPartitionedTopicMetadataResponse_LookupType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandLookupTopic {
    // message fields
    topic: ::protobuf::SingularField<::std::string::String>,
    request_id: ::std::option::Option<u64>,
    authoritative: ::std::option::Option<bool>,
    original_principal: ::protobuf::SingularField<::std::string::String>,
    original_auth_data: ::protobuf::SingularField<::std::string::String>,
    original_auth_method: ::protobuf::SingularField<::std::string::String>,
    advertised_listener_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandLookupTopic {
    fn default() -> &'a CommandLookupTopic {
        <CommandLookupTopic as ::protobuf::Message>::default_instance()
    }
}

impl CommandLookupTopic {
    pub fn new() -> CommandLookupTopic {
        ::std::default::Default::default()
    }

    // required string topic = 1;


    pub fn get_topic(&self) -> &str {
        match self.topic.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    pub fn has_topic(&self) -> bool {
        self.topic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        if self.topic.is_none() {
            self.topic.set_default();
        }
        self.topic.as_mut().unwrap()
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        self.topic.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 request_id = 2;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional bool authoritative = 3;


    pub fn get_authoritative(&self) -> bool {
        self.authoritative.unwrap_or(false)
    }
    pub fn clear_authoritative(&mut self) {
        self.authoritative = ::std::option::Option::None;
    }

    pub fn has_authoritative(&self) -> bool {
        self.authoritative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authoritative(&mut self, v: bool) {
        self.authoritative = ::std::option::Option::Some(v);
    }

    // optional string original_principal = 4;


    pub fn get_original_principal(&self) -> &str {
        match self.original_principal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_original_principal(&mut self) {
        self.original_principal.clear();
    }

    pub fn has_original_principal(&self) -> bool {
        self.original_principal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_principal(&mut self, v: ::std::string::String) {
        self.original_principal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_principal(&mut self) -> &mut ::std::string::String {
        if self.original_principal.is_none() {
            self.original_principal.set_default();
        }
        self.original_principal.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_principal(&mut self) -> ::std::string::String {
        self.original_principal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string original_auth_data = 5;


    pub fn get_original_auth_data(&self) -> &str {
        match self.original_auth_data.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_original_auth_data(&mut self) {
        self.original_auth_data.clear();
    }

    pub fn has_original_auth_data(&self) -> bool {
        self.original_auth_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_auth_data(&mut self, v: ::std::string::String) {
        self.original_auth_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_auth_data(&mut self) -> &mut ::std::string::String {
        if self.original_auth_data.is_none() {
            self.original_auth_data.set_default();
        }
        self.original_auth_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_auth_data(&mut self) -> ::std::string::String {
        self.original_auth_data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string original_auth_method = 6;


    pub fn get_original_auth_method(&self) -> &str {
        match self.original_auth_method.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_original_auth_method(&mut self) {
        self.original_auth_method.clear();
    }

    pub fn has_original_auth_method(&self) -> bool {
        self.original_auth_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_auth_method(&mut self, v: ::std::string::String) {
        self.original_auth_method = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_auth_method(&mut self) -> &mut ::std::string::String {
        if self.original_auth_method.is_none() {
            self.original_auth_method.set_default();
        }
        self.original_auth_method.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_auth_method(&mut self) -> ::std::string::String {
        self.original_auth_method.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string advertised_listener_name = 7;


    pub fn get_advertised_listener_name(&self) -> &str {
        match self.advertised_listener_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_advertised_listener_name(&mut self) {
        self.advertised_listener_name.clear();
    }

    pub fn has_advertised_listener_name(&self) -> bool {
        self.advertised_listener_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_advertised_listener_name(&mut self, v: ::std::string::String) {
        self.advertised_listener_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_advertised_listener_name(&mut self) -> &mut ::std::string::String {
        if self.advertised_listener_name.is_none() {
            self.advertised_listener_name.set_default();
        }
        self.advertised_listener_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_advertised_listener_name(&mut self) -> ::std::string::String {
        self.advertised_listener_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CommandLookupTopic {
    fn is_initialized(&self) -> bool {
        if self.topic.is_none() {
            return false;
        }
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.topic)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.authoritative = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.original_principal)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.original_auth_data)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.original_auth_method)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.advertised_listener_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.topic.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.authoritative {
            my_size += 2;
        }
        if let Some(ref v) = self.original_principal.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.original_auth_data.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.original_auth_method.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.advertised_listener_name.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.topic.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.authoritative {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.original_principal.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.original_auth_data.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.original_auth_method.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.advertised_listener_name.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandLookupTopic {
        CommandLookupTopic::new()
    }

    fn default_instance() -> &'static CommandLookupTopic {
        static instance: ::protobuf::rt::LazyV2<CommandLookupTopic> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandLookupTopic::new)
    }
}

impl ::protobuf::Clear for CommandLookupTopic {
    fn clear(&mut self) {
        self.topic.clear();
        self.request_id = ::std::option::Option::None;
        self.authoritative = ::std::option::Option::None;
        self.original_principal.clear();
        self.original_auth_data.clear();
        self.original_auth_method.clear();
        self.advertised_listener_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandLookupTopic {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandLookupTopicResponse {
    // message fields
    brokerServiceUrl: ::protobuf::SingularField<::std::string::String>,
    brokerServiceUrlTls: ::protobuf::SingularField<::std::string::String>,
    response: ::std::option::Option<CommandLookupTopicResponse_LookupType>,
    request_id: ::std::option::Option<u64>,
    authoritative: ::std::option::Option<bool>,
    error: ::std::option::Option<ServerError>,
    message: ::protobuf::SingularField<::std::string::String>,
    proxy_through_service_url: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandLookupTopicResponse {
    fn default() -> &'a CommandLookupTopicResponse {
        <CommandLookupTopicResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommandLookupTopicResponse {
    pub fn new() -> CommandLookupTopicResponse {
        ::std::default::Default::default()
    }

    // optional string brokerServiceUrl = 1;


    pub fn get_brokerServiceUrl(&self) -> &str {
        match self.brokerServiceUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_brokerServiceUrl(&mut self) {
        self.brokerServiceUrl.clear();
    }

    pub fn has_brokerServiceUrl(&self) -> bool {
        self.brokerServiceUrl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_brokerServiceUrl(&mut self, v: ::std::string::String) {
        self.brokerServiceUrl = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_brokerServiceUrl(&mut self) -> &mut ::std::string::String {
        if self.brokerServiceUrl.is_none() {
            self.brokerServiceUrl.set_default();
        }
        self.brokerServiceUrl.as_mut().unwrap()
    }

    // Take field
    pub fn take_brokerServiceUrl(&mut self) -> ::std::string::String {
        self.brokerServiceUrl.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string brokerServiceUrlTls = 2;


    pub fn get_brokerServiceUrlTls(&self) -> &str {
        match self.brokerServiceUrlTls.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_brokerServiceUrlTls(&mut self) {
        self.brokerServiceUrlTls.clear();
    }

    pub fn has_brokerServiceUrlTls(&self) -> bool {
        self.brokerServiceUrlTls.is_some()
    }

    // Param is passed by value, moved
    pub fn set_brokerServiceUrlTls(&mut self, v: ::std::string::String) {
        self.brokerServiceUrlTls = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_brokerServiceUrlTls(&mut self) -> &mut ::std::string::String {
        if self.brokerServiceUrlTls.is_none() {
            self.brokerServiceUrlTls.set_default();
        }
        self.brokerServiceUrlTls.as_mut().unwrap()
    }

    // Take field
    pub fn take_brokerServiceUrlTls(&mut self) -> ::std::string::String {
        self.brokerServiceUrlTls.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .pulsar.proto.CommandLookupTopicResponse.LookupType response = 3;


    pub fn get_response(&self) -> CommandLookupTopicResponse_LookupType {
        self.response.unwrap_or(CommandLookupTopicResponse_LookupType::Redirect)
    }
    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: CommandLookupTopicResponse_LookupType) {
        self.response = ::std::option::Option::Some(v);
    }

    // required uint64 request_id = 4;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional bool authoritative = 5;


    pub fn get_authoritative(&self) -> bool {
        self.authoritative.unwrap_or(false)
    }
    pub fn clear_authoritative(&mut self) {
        self.authoritative = ::std::option::Option::None;
    }

    pub fn has_authoritative(&self) -> bool {
        self.authoritative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authoritative(&mut self, v: bool) {
        self.authoritative = ::std::option::Option::Some(v);
    }

    // optional .pulsar.proto.ServerError error = 6;


    pub fn get_error(&self) -> ServerError {
        self.error.unwrap_or(ServerError::UnknownError)
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ServerError) {
        self.error = ::std::option::Option::Some(v);
    }

    // optional string message = 7;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool proxy_through_service_url = 8;


    pub fn get_proxy_through_service_url(&self) -> bool {
        self.proxy_through_service_url.unwrap_or(false)
    }
    pub fn clear_proxy_through_service_url(&mut self) {
        self.proxy_through_service_url = ::std::option::Option::None;
    }

    pub fn has_proxy_through_service_url(&self) -> bool {
        self.proxy_through_service_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proxy_through_service_url(&mut self, v: bool) {
        self.proxy_through_service_url = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandLookupTopicResponse {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.brokerServiceUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.brokerServiceUrlTls)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.response, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.authoritative = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 6, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.proxy_through_service_url = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.brokerServiceUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.brokerServiceUrlTls.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.authoritative {
            my_size += 2;
        }
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.proxy_through_service_url {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.brokerServiceUrl.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.brokerServiceUrlTls.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.response {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.authoritative {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.error {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.proxy_through_service_url {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandLookupTopicResponse {
        CommandLookupTopicResponse::new()
    }

    fn default_instance() -> &'static CommandLookupTopicResponse {
        static instance: ::protobuf::rt::LazyV2<CommandLookupTopicResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandLookupTopicResponse::new)
    }
}

impl ::protobuf::Clear for CommandLookupTopicResponse {
    fn clear(&mut self) {
        self.brokerServiceUrl.clear();
        self.brokerServiceUrlTls.clear();
        self.response = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.authoritative = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.message.clear();
        self.proxy_through_service_url = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandLookupTopicResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommandLookupTopicResponse_LookupType {
    Redirect = 0,
    Connect = 1,
    Failed = 2,
}

impl ::protobuf::ProtobufEnum for CommandLookupTopicResponse_LookupType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommandLookupTopicResponse_LookupType> {
        match value {
            0 => ::std::option::Option::Some(CommandLookupTopicResponse_LookupType::Redirect),
            1 => ::std::option::Option::Some(CommandLookupTopicResponse_LookupType::Connect),
            2 => ::std::option::Option::Some(CommandLookupTopicResponse_LookupType::Failed),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommandLookupTopicResponse_LookupType] = &[
            CommandLookupTopicResponse_LookupType::Redirect,
            CommandLookupTopicResponse_LookupType::Connect,
            CommandLookupTopicResponse_LookupType::Failed,
        ];
        values
    }
}

impl ::std::marker::Copy for CommandLookupTopicResponse_LookupType {
}

impl ::std::default::Default for CommandLookupTopicResponse_LookupType {
    fn default() -> Self {
        CommandLookupTopicResponse_LookupType::Redirect
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandLookupTopicResponse_LookupType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandProducer {
    // message fields
    topic: ::protobuf::SingularField<::std::string::String>,
    producer_id: ::std::option::Option<u64>,
    request_id: ::std::option::Option<u64>,
    producer_name: ::protobuf::SingularField<::std::string::String>,
    encrypted: ::std::option::Option<bool>,
    pub metadata: ::protobuf::RepeatedField<KeyValue>,
    pub schema: ::protobuf::SingularPtrField<Schema>,
    epoch: ::std::option::Option<u64>,
    user_provided_producer_name: ::std::option::Option<bool>,
    producer_access_mode: ::std::option::Option<ProducerAccessMode>,
    topic_epoch: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandProducer {
    fn default() -> &'a CommandProducer {
        <CommandProducer as ::protobuf::Message>::default_instance()
    }
}

impl CommandProducer {
    pub fn new() -> CommandProducer {
        ::std::default::Default::default()
    }

    // required string topic = 1;


    pub fn get_topic(&self) -> &str {
        match self.topic.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    pub fn has_topic(&self) -> bool {
        self.topic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        if self.topic.is_none() {
            self.topic.set_default();
        }
        self.topic.as_mut().unwrap()
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        self.topic.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 producer_id = 2;


    pub fn get_producer_id(&self) -> u64 {
        self.producer_id.unwrap_or(0)
    }
    pub fn clear_producer_id(&mut self) {
        self.producer_id = ::std::option::Option::None;
    }

    pub fn has_producer_id(&self) -> bool {
        self.producer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_id(&mut self, v: u64) {
        self.producer_id = ::std::option::Option::Some(v);
    }

    // required uint64 request_id = 3;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional string producer_name = 4;


    pub fn get_producer_name(&self) -> &str {
        match self.producer_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_producer_name(&mut self) {
        self.producer_name.clear();
    }

    pub fn has_producer_name(&self) -> bool {
        self.producer_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_name(&mut self, v: ::std::string::String) {
        self.producer_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_producer_name(&mut self) -> &mut ::std::string::String {
        if self.producer_name.is_none() {
            self.producer_name.set_default();
        }
        self.producer_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_producer_name(&mut self) -> ::std::string::String {
        self.producer_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool encrypted = 5;


    pub fn get_encrypted(&self) -> bool {
        self.encrypted.unwrap_or(false)
    }
    pub fn clear_encrypted(&mut self) {
        self.encrypted = ::std::option::Option::None;
    }

    pub fn has_encrypted(&self) -> bool {
        self.encrypted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypted(&mut self, v: bool) {
        self.encrypted = ::std::option::Option::Some(v);
    }

    // repeated .pulsar.proto.KeyValue metadata = 6;


    pub fn get_metadata(&self) -> &[KeyValue] {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::RepeatedField<KeyValue>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::RepeatedField<KeyValue> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::RepeatedField<KeyValue> {
        ::std::mem::replace(&mut self.metadata, ::protobuf::RepeatedField::new())
    }

    // optional .pulsar.proto.Schema schema = 7;


    pub fn get_schema(&self) -> &Schema {
        self.schema.as_ref().unwrap_or_else(|| <Schema as ::protobuf::Message>::default_instance())
    }
    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: Schema) {
        self.schema = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut Schema {
        if self.schema.is_none() {
            self.schema.set_default();
        }
        self.schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema(&mut self) -> Schema {
        self.schema.take().unwrap_or_else(|| Schema::new())
    }

    // optional uint64 epoch = 8;


    pub fn get_epoch(&self) -> u64 {
        self.epoch.unwrap_or(0u64)
    }
    pub fn clear_epoch(&mut self) {
        self.epoch = ::std::option::Option::None;
    }

    pub fn has_epoch(&self) -> bool {
        self.epoch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_epoch(&mut self, v: u64) {
        self.epoch = ::std::option::Option::Some(v);
    }

    // optional bool user_provided_producer_name = 9;


    pub fn get_user_provided_producer_name(&self) -> bool {
        self.user_provided_producer_name.unwrap_or(true)
    }
    pub fn clear_user_provided_producer_name(&mut self) {
        self.user_provided_producer_name = ::std::option::Option::None;
    }

    pub fn has_user_provided_producer_name(&self) -> bool {
        self.user_provided_producer_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_provided_producer_name(&mut self, v: bool) {
        self.user_provided_producer_name = ::std::option::Option::Some(v);
    }

    // optional .pulsar.proto.ProducerAccessMode producer_access_mode = 10;


    pub fn get_producer_access_mode(&self) -> ProducerAccessMode {
        self.producer_access_mode.unwrap_or(ProducerAccessMode::Shared)
    }
    pub fn clear_producer_access_mode(&mut self) {
        self.producer_access_mode = ::std::option::Option::None;
    }

    pub fn has_producer_access_mode(&self) -> bool {
        self.producer_access_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_access_mode(&mut self, v: ProducerAccessMode) {
        self.producer_access_mode = ::std::option::Option::Some(v);
    }

    // optional uint64 topic_epoch = 11;


    pub fn get_topic_epoch(&self) -> u64 {
        self.topic_epoch.unwrap_or(0)
    }
    pub fn clear_topic_epoch(&mut self) {
        self.topic_epoch = ::std::option::Option::None;
    }

    pub fn has_topic_epoch(&self) -> bool {
        self.topic_epoch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topic_epoch(&mut self, v: u64) {
        self.topic_epoch = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandProducer {
    fn is_initialized(&self) -> bool {
        if self.topic.is_none() {
            return false;
        }
        if self.producer_id.is_none() {
            return false;
        }
        if self.request_id.is_none() {
            return false;
        }
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.schema {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.topic)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.producer_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.producer_name)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.encrypted = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metadata)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.schema)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.epoch = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.user_provided_producer_name = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.producer_access_mode, 10, &mut self.unknown_fields)?
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.topic_epoch = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.topic.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.producer_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.producer_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.encrypted {
            my_size += 2;
        }
        for value in &self.metadata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.schema.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.epoch {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.user_provided_producer_name {
            my_size += 2;
        }
        if let Some(v) = self.producer_access_mode {
            my_size += ::protobuf::rt::enum_size(10, v);
        }
        if let Some(v) = self.topic_epoch {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.topic.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.producer_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(3, v)?;
        }
        if let Some(ref v) = self.producer_name.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.encrypted {
            os.write_bool(5, v)?;
        }
        for v in &self.metadata {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.schema.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.epoch {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.user_provided_producer_name {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.producer_access_mode {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.topic_epoch {
            os.write_uint64(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandProducer {
        CommandProducer::new()
    }

    fn default_instance() -> &'static CommandProducer {
        static instance: ::protobuf::rt::LazyV2<CommandProducer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandProducer::new)
    }
}

impl ::protobuf::Clear for CommandProducer {
    fn clear(&mut self) {
        self.topic.clear();
        self.producer_id = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.producer_name.clear();
        self.encrypted = ::std::option::Option::None;
        self.metadata.clear();
        self.schema.clear();
        self.epoch = ::std::option::Option::None;
        self.user_provided_producer_name = ::std::option::Option::None;
        self.producer_access_mode = ::std::option::Option::None;
        self.topic_epoch = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandProducer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandSend {
    // message fields
    producer_id: ::std::option::Option<u64>,
    sequence_id: ::std::option::Option<u64>,
    num_messages: ::std::option::Option<i32>,
    txnid_least_bits: ::std::option::Option<u64>,
    txnid_most_bits: ::std::option::Option<u64>,
    highest_sequence_id: ::std::option::Option<u64>,
    is_chunk: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandSend {
    fn default() -> &'a CommandSend {
        <CommandSend as ::protobuf::Message>::default_instance()
    }
}

impl CommandSend {
    pub fn new() -> CommandSend {
        ::std::default::Default::default()
    }

    // required uint64 producer_id = 1;


    pub fn get_producer_id(&self) -> u64 {
        self.producer_id.unwrap_or(0)
    }
    pub fn clear_producer_id(&mut self) {
        self.producer_id = ::std::option::Option::None;
    }

    pub fn has_producer_id(&self) -> bool {
        self.producer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_id(&mut self, v: u64) {
        self.producer_id = ::std::option::Option::Some(v);
    }

    // required uint64 sequence_id = 2;


    pub fn get_sequence_id(&self) -> u64 {
        self.sequence_id.unwrap_or(0)
    }
    pub fn clear_sequence_id(&mut self) {
        self.sequence_id = ::std::option::Option::None;
    }

    pub fn has_sequence_id(&self) -> bool {
        self.sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_id(&mut self, v: u64) {
        self.sequence_id = ::std::option::Option::Some(v);
    }

    // optional int32 num_messages = 3;


    pub fn get_num_messages(&self) -> i32 {
        self.num_messages.unwrap_or(1i32)
    }
    pub fn clear_num_messages(&mut self) {
        self.num_messages = ::std::option::Option::None;
    }

    pub fn has_num_messages(&self) -> bool {
        self.num_messages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_messages(&mut self, v: i32) {
        self.num_messages = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_least_bits = 4;


    pub fn get_txnid_least_bits(&self) -> u64 {
        self.txnid_least_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_least_bits(&mut self) {
        self.txnid_least_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_least_bits(&self) -> bool {
        self.txnid_least_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_least_bits(&mut self, v: u64) {
        self.txnid_least_bits = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_most_bits = 5;


    pub fn get_txnid_most_bits(&self) -> u64 {
        self.txnid_most_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_most_bits(&mut self) {
        self.txnid_most_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_most_bits(&self) -> bool {
        self.txnid_most_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_most_bits(&mut self, v: u64) {
        self.txnid_most_bits = ::std::option::Option::Some(v);
    }

    // optional uint64 highest_sequence_id = 6;


    pub fn get_highest_sequence_id(&self) -> u64 {
        self.highest_sequence_id.unwrap_or(0u64)
    }
    pub fn clear_highest_sequence_id(&mut self) {
        self.highest_sequence_id = ::std::option::Option::None;
    }

    pub fn has_highest_sequence_id(&self) -> bool {
        self.highest_sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_highest_sequence_id(&mut self, v: u64) {
        self.highest_sequence_id = ::std::option::Option::Some(v);
    }

    // optional bool is_chunk = 7;


    pub fn get_is_chunk(&self) -> bool {
        self.is_chunk.unwrap_or(false)
    }
    pub fn clear_is_chunk(&mut self) {
        self.is_chunk = ::std::option::Option::None;
    }

    pub fn has_is_chunk(&self) -> bool {
        self.is_chunk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_chunk(&mut self, v: bool) {
        self.is_chunk = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandSend {
    fn is_initialized(&self) -> bool {
        if self.producer_id.is_none() {
            return false;
        }
        if self.sequence_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.producer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_messages = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_least_bits = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_most_bits = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.highest_sequence_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_chunk = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.producer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sequence_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_messages {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_least_bits {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_most_bits {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.highest_sequence_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_chunk {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.producer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.sequence_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.num_messages {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.txnid_least_bits {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.txnid_most_bits {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.highest_sequence_id {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.is_chunk {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandSend {
        CommandSend::new()
    }

    fn default_instance() -> &'static CommandSend {
        static instance: ::protobuf::rt::LazyV2<CommandSend> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandSend::new)
    }
}

impl ::protobuf::Clear for CommandSend {
    fn clear(&mut self) {
        self.producer_id = ::std::option::Option::None;
        self.sequence_id = ::std::option::Option::None;
        self.num_messages = ::std::option::Option::None;
        self.txnid_least_bits = ::std::option::Option::None;
        self.txnid_most_bits = ::std::option::Option::None;
        self.highest_sequence_id = ::std::option::Option::None;
        self.is_chunk = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandSend {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandSendReceipt {
    // message fields
    producer_id: ::std::option::Option<u64>,
    sequence_id: ::std::option::Option<u64>,
    pub message_id: ::protobuf::SingularPtrField<MessageIdData>,
    highest_sequence_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandSendReceipt {
    fn default() -> &'a CommandSendReceipt {
        <CommandSendReceipt as ::protobuf::Message>::default_instance()
    }
}

impl CommandSendReceipt {
    pub fn new() -> CommandSendReceipt {
        ::std::default::Default::default()
    }

    // required uint64 producer_id = 1;


    pub fn get_producer_id(&self) -> u64 {
        self.producer_id.unwrap_or(0)
    }
    pub fn clear_producer_id(&mut self) {
        self.producer_id = ::std::option::Option::None;
    }

    pub fn has_producer_id(&self) -> bool {
        self.producer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_id(&mut self, v: u64) {
        self.producer_id = ::std::option::Option::Some(v);
    }

    // required uint64 sequence_id = 2;


    pub fn get_sequence_id(&self) -> u64 {
        self.sequence_id.unwrap_or(0)
    }
    pub fn clear_sequence_id(&mut self) {
        self.sequence_id = ::std::option::Option::None;
    }

    pub fn has_sequence_id(&self) -> bool {
        self.sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_id(&mut self, v: u64) {
        self.sequence_id = ::std::option::Option::Some(v);
    }

    // optional .pulsar.proto.MessageIdData message_id = 3;


    pub fn get_message_id(&self) -> &MessageIdData {
        self.message_id.as_ref().unwrap_or_else(|| <MessageIdData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    pub fn has_message_id(&self) -> bool {
        self.message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: MessageIdData) {
        self.message_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut MessageIdData {
        if self.message_id.is_none() {
            self.message_id.set_default();
        }
        self.message_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_id(&mut self) -> MessageIdData {
        self.message_id.take().unwrap_or_else(|| MessageIdData::new())
    }

    // optional uint64 highest_sequence_id = 4;


    pub fn get_highest_sequence_id(&self) -> u64 {
        self.highest_sequence_id.unwrap_or(0u64)
    }
    pub fn clear_highest_sequence_id(&mut self) {
        self.highest_sequence_id = ::std::option::Option::None;
    }

    pub fn has_highest_sequence_id(&self) -> bool {
        self.highest_sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_highest_sequence_id(&mut self, v: u64) {
        self.highest_sequence_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandSendReceipt {
    fn is_initialized(&self) -> bool {
        if self.producer_id.is_none() {
            return false;
        }
        if self.sequence_id.is_none() {
            return false;
        }
        for v in &self.message_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.producer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.highest_sequence_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.producer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sequence_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.highest_sequence_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.producer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.sequence_id {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.message_id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.highest_sequence_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandSendReceipt {
        CommandSendReceipt::new()
    }

    fn default_instance() -> &'static CommandSendReceipt {
        static instance: ::protobuf::rt::LazyV2<CommandSendReceipt> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandSendReceipt::new)
    }
}

impl ::protobuf::Clear for CommandSendReceipt {
    fn clear(&mut self) {
        self.producer_id = ::std::option::Option::None;
        self.sequence_id = ::std::option::Option::None;
        self.message_id.clear();
        self.highest_sequence_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandSendReceipt {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandSendError {
    // message fields
    producer_id: ::std::option::Option<u64>,
    sequence_id: ::std::option::Option<u64>,
    error: ::std::option::Option<ServerError>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandSendError {
    fn default() -> &'a CommandSendError {
        <CommandSendError as ::protobuf::Message>::default_instance()
    }
}

impl CommandSendError {
    pub fn new() -> CommandSendError {
        ::std::default::Default::default()
    }

    // required uint64 producer_id = 1;


    pub fn get_producer_id(&self) -> u64 {
        self.producer_id.unwrap_or(0)
    }
    pub fn clear_producer_id(&mut self) {
        self.producer_id = ::std::option::Option::None;
    }

    pub fn has_producer_id(&self) -> bool {
        self.producer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_id(&mut self, v: u64) {
        self.producer_id = ::std::option::Option::Some(v);
    }

    // required uint64 sequence_id = 2;


    pub fn get_sequence_id(&self) -> u64 {
        self.sequence_id.unwrap_or(0)
    }
    pub fn clear_sequence_id(&mut self) {
        self.sequence_id = ::std::option::Option::None;
    }

    pub fn has_sequence_id(&self) -> bool {
        self.sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_id(&mut self, v: u64) {
        self.sequence_id = ::std::option::Option::Some(v);
    }

    // required .pulsar.proto.ServerError error = 3;


    pub fn get_error(&self) -> ServerError {
        self.error.unwrap_or(ServerError::UnknownError)
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ServerError) {
        self.error = ::std::option::Option::Some(v);
    }

    // required string message = 4;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CommandSendError {
    fn is_initialized(&self) -> bool {
        if self.producer_id.is_none() {
            return false;
        }
        if self.sequence_id.is_none() {
            return false;
        }
        if self.error.is_none() {
            return false;
        }
        if self.message.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.producer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.producer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sequence_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.producer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.sequence_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.error {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandSendError {
        CommandSendError::new()
    }

    fn default_instance() -> &'static CommandSendError {
        static instance: ::protobuf::rt::LazyV2<CommandSendError> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandSendError::new)
    }
}

impl ::protobuf::Clear for CommandSendError {
    fn clear(&mut self) {
        self.producer_id = ::std::option::Option::None;
        self.sequence_id = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandSendError {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandMessage {
    // message fields
    consumer_id: ::std::option::Option<u64>,
    pub message_id: ::protobuf::SingularPtrField<MessageIdData>,
    redelivery_count: ::std::option::Option<u32>,
    pub ack_set: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandMessage {
    fn default() -> &'a CommandMessage {
        <CommandMessage as ::protobuf::Message>::default_instance()
    }
}

impl CommandMessage {
    pub fn new() -> CommandMessage {
        ::std::default::Default::default()
    }

    // required uint64 consumer_id = 1;


    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }
    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }

    // required .pulsar.proto.MessageIdData message_id = 2;


    pub fn get_message_id(&self) -> &MessageIdData {
        self.message_id.as_ref().unwrap_or_else(|| <MessageIdData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    pub fn has_message_id(&self) -> bool {
        self.message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: MessageIdData) {
        self.message_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut MessageIdData {
        if self.message_id.is_none() {
            self.message_id.set_default();
        }
        self.message_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_id(&mut self) -> MessageIdData {
        self.message_id.take().unwrap_or_else(|| MessageIdData::new())
    }

    // optional uint32 redelivery_count = 3;


    pub fn get_redelivery_count(&self) -> u32 {
        self.redelivery_count.unwrap_or(0u32)
    }
    pub fn clear_redelivery_count(&mut self) {
        self.redelivery_count = ::std::option::Option::None;
    }

    pub fn has_redelivery_count(&self) -> bool {
        self.redelivery_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_redelivery_count(&mut self, v: u32) {
        self.redelivery_count = ::std::option::Option::Some(v);
    }

    // repeated int64 ack_set = 4;


    pub fn get_ack_set(&self) -> &[i64] {
        &self.ack_set
    }
    pub fn clear_ack_set(&mut self) {
        self.ack_set.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_set(&mut self, v: ::std::vec::Vec<i64>) {
        self.ack_set = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_set(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.ack_set
    }

    // Take field
    pub fn take_ack_set(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.ack_set, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CommandMessage {
    fn is_initialized(&self) -> bool {
        if self.consumer_id.is_none() {
            return false;
        }
        if self.message_id.is_none() {
            return false;
        }
        for v in &self.message_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.redelivery_count = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.ack_set)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.redelivery_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.ack_set {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.consumer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.message_id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.redelivery_count {
            os.write_uint32(3, v)?;
        }
        for v in &self.ack_set {
            os.write_int64(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandMessage {
        CommandMessage::new()
    }

    fn default_instance() -> &'static CommandMessage {
        static instance: ::protobuf::rt::LazyV2<CommandMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandMessage::new)
    }
}

impl ::protobuf::Clear for CommandMessage {
    fn clear(&mut self) {
        self.consumer_id = ::std::option::Option::None;
        self.message_id.clear();
        self.redelivery_count = ::std::option::Option::None;
        self.ack_set.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandAck {
    // message fields
    consumer_id: ::std::option::Option<u64>,
    ack_type: ::std::option::Option<CommandAck_AckType>,
    pub message_id: ::protobuf::RepeatedField<MessageIdData>,
    validation_error: ::std::option::Option<CommandAck_ValidationError>,
    pub properties: ::protobuf::RepeatedField<KeyLongValue>,
    txnid_least_bits: ::std::option::Option<u64>,
    txnid_most_bits: ::std::option::Option<u64>,
    request_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandAck {
    fn default() -> &'a CommandAck {
        <CommandAck as ::protobuf::Message>::default_instance()
    }
}

impl CommandAck {
    pub fn new() -> CommandAck {
        ::std::default::Default::default()
    }

    // required uint64 consumer_id = 1;


    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }
    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }

    // required .pulsar.proto.CommandAck.AckType ack_type = 2;


    pub fn get_ack_type(&self) -> CommandAck_AckType {
        self.ack_type.unwrap_or(CommandAck_AckType::Individual)
    }
    pub fn clear_ack_type(&mut self) {
        self.ack_type = ::std::option::Option::None;
    }

    pub fn has_ack_type(&self) -> bool {
        self.ack_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_type(&mut self, v: CommandAck_AckType) {
        self.ack_type = ::std::option::Option::Some(v);
    }

    // repeated .pulsar.proto.MessageIdData message_id = 3;


    pub fn get_message_id(&self) -> &[MessageIdData] {
        &self.message_id
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::protobuf::RepeatedField<MessageIdData>) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_message_id(&mut self) -> &mut ::protobuf::RepeatedField<MessageIdData> {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::protobuf::RepeatedField<MessageIdData> {
        ::std::mem::replace(&mut self.message_id, ::protobuf::RepeatedField::new())
    }

    // optional .pulsar.proto.CommandAck.ValidationError validation_error = 4;


    pub fn get_validation_error(&self) -> CommandAck_ValidationError {
        self.validation_error.unwrap_or(CommandAck_ValidationError::UncompressedSizeCorruption)
    }
    pub fn clear_validation_error(&mut self) {
        self.validation_error = ::std::option::Option::None;
    }

    pub fn has_validation_error(&self) -> bool {
        self.validation_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_validation_error(&mut self, v: CommandAck_ValidationError) {
        self.validation_error = ::std::option::Option::Some(v);
    }

    // repeated .pulsar.proto.KeyLongValue properties = 5;


    pub fn get_properties(&self) -> &[KeyLongValue] {
        &self.properties
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<KeyLongValue>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<KeyLongValue> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<KeyLongValue> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }

    // optional uint64 txnid_least_bits = 6;


    pub fn get_txnid_least_bits(&self) -> u64 {
        self.txnid_least_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_least_bits(&mut self) {
        self.txnid_least_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_least_bits(&self) -> bool {
        self.txnid_least_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_least_bits(&mut self, v: u64) {
        self.txnid_least_bits = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_most_bits = 7;


    pub fn get_txnid_most_bits(&self) -> u64 {
        self.txnid_most_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_most_bits(&mut self) {
        self.txnid_most_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_most_bits(&self) -> bool {
        self.txnid_most_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_most_bits(&mut self, v: u64) {
        self.txnid_most_bits = ::std::option::Option::Some(v);
    }

    // optional uint64 request_id = 8;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandAck {
    fn is_initialized(&self) -> bool {
        if self.consumer_id.is_none() {
            return false;
        }
        if self.ack_type.is_none() {
            return false;
        }
        for v in &self.message_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.ack_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.message_id)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.validation_error, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_least_bits = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_most_bits = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ack_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        for value in &self.message_id {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.validation_error {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.txnid_least_bits {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_most_bits {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.consumer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.ack_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.message_id {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.validation_error {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.properties {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.txnid_least_bits {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.txnid_most_bits {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandAck {
        CommandAck::new()
    }

    fn default_instance() -> &'static CommandAck {
        static instance: ::protobuf::rt::LazyV2<CommandAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandAck::new)
    }
}

impl ::protobuf::Clear for CommandAck {
    fn clear(&mut self) {
        self.consumer_id = ::std::option::Option::None;
        self.ack_type = ::std::option::Option::None;
        self.message_id.clear();
        self.validation_error = ::std::option::Option::None;
        self.properties.clear();
        self.txnid_least_bits = ::std::option::Option::None;
        self.txnid_most_bits = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommandAck_AckType {
    Individual = 0,
    Cumulative = 1,
}

impl ::protobuf::ProtobufEnum for CommandAck_AckType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommandAck_AckType> {
        match value {
            0 => ::std::option::Option::Some(CommandAck_AckType::Individual),
            1 => ::std::option::Option::Some(CommandAck_AckType::Cumulative),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommandAck_AckType] = &[
            CommandAck_AckType::Individual,
            CommandAck_AckType::Cumulative,
        ];
        values
    }
}

impl ::std::marker::Copy for CommandAck_AckType {
}

impl ::std::default::Default for CommandAck_AckType {
    fn default() -> Self {
        CommandAck_AckType::Individual
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandAck_AckType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommandAck_ValidationError {
    UncompressedSizeCorruption = 0,
    DecompressionError = 1,
    ChecksumMismatch = 2,
    BatchDeSerializeError = 3,
    DecryptionError = 4,
}

impl ::protobuf::ProtobufEnum for CommandAck_ValidationError {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommandAck_ValidationError> {
        match value {
            0 => ::std::option::Option::Some(CommandAck_ValidationError::UncompressedSizeCorruption),
            1 => ::std::option::Option::Some(CommandAck_ValidationError::DecompressionError),
            2 => ::std::option::Option::Some(CommandAck_ValidationError::ChecksumMismatch),
            3 => ::std::option::Option::Some(CommandAck_ValidationError::BatchDeSerializeError),
            4 => ::std::option::Option::Some(CommandAck_ValidationError::DecryptionError),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommandAck_ValidationError] = &[
            CommandAck_ValidationError::UncompressedSizeCorruption,
            CommandAck_ValidationError::DecompressionError,
            CommandAck_ValidationError::ChecksumMismatch,
            CommandAck_ValidationError::BatchDeSerializeError,
            CommandAck_ValidationError::DecryptionError,
        ];
        values
    }
}

impl ::std::marker::Copy for CommandAck_ValidationError {
}

impl ::std::default::Default for CommandAck_ValidationError {
    fn default() -> Self {
        CommandAck_ValidationError::UncompressedSizeCorruption
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandAck_ValidationError {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandAckResponse {
    // message fields
    consumer_id: ::std::option::Option<u64>,
    txnid_least_bits: ::std::option::Option<u64>,
    txnid_most_bits: ::std::option::Option<u64>,
    error: ::std::option::Option<ServerError>,
    message: ::protobuf::SingularField<::std::string::String>,
    request_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandAckResponse {
    fn default() -> &'a CommandAckResponse {
        <CommandAckResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommandAckResponse {
    pub fn new() -> CommandAckResponse {
        ::std::default::Default::default()
    }

    // required uint64 consumer_id = 1;


    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }
    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_least_bits = 2;


    pub fn get_txnid_least_bits(&self) -> u64 {
        self.txnid_least_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_least_bits(&mut self) {
        self.txnid_least_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_least_bits(&self) -> bool {
        self.txnid_least_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_least_bits(&mut self, v: u64) {
        self.txnid_least_bits = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_most_bits = 3;


    pub fn get_txnid_most_bits(&self) -> u64 {
        self.txnid_most_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_most_bits(&mut self) {
        self.txnid_most_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_most_bits(&self) -> bool {
        self.txnid_most_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_most_bits(&mut self, v: u64) {
        self.txnid_most_bits = ::std::option::Option::Some(v);
    }

    // optional .pulsar.proto.ServerError error = 4;


    pub fn get_error(&self) -> ServerError {
        self.error.unwrap_or(ServerError::UnknownError)
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ServerError) {
        self.error = ::std::option::Option::Some(v);
    }

    // optional string message = 5;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 request_id = 6;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandAckResponse {
    fn is_initialized(&self) -> bool {
        if self.consumer_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_least_bits = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_most_bits = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_least_bits {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_most_bits {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.consumer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.txnid_least_bits {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.txnid_most_bits {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.error {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandAckResponse {
        CommandAckResponse::new()
    }

    fn default_instance() -> &'static CommandAckResponse {
        static instance: ::protobuf::rt::LazyV2<CommandAckResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandAckResponse::new)
    }
}

impl ::protobuf::Clear for CommandAckResponse {
    fn clear(&mut self) {
        self.consumer_id = ::std::option::Option::None;
        self.txnid_least_bits = ::std::option::Option::None;
        self.txnid_most_bits = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.message.clear();
        self.request_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandAckResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandActiveConsumerChange {
    // message fields
    consumer_id: ::std::option::Option<u64>,
    is_active: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandActiveConsumerChange {
    fn default() -> &'a CommandActiveConsumerChange {
        <CommandActiveConsumerChange as ::protobuf::Message>::default_instance()
    }
}

impl CommandActiveConsumerChange {
    pub fn new() -> CommandActiveConsumerChange {
        ::std::default::Default::default()
    }

    // required uint64 consumer_id = 1;


    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }
    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }

    // optional bool is_active = 2;


    pub fn get_is_active(&self) -> bool {
        self.is_active.unwrap_or(false)
    }
    pub fn clear_is_active(&mut self) {
        self.is_active = ::std::option::Option::None;
    }

    pub fn has_is_active(&self) -> bool {
        self.is_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_active(&mut self, v: bool) {
        self.is_active = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandActiveConsumerChange {
    fn is_initialized(&self) -> bool {
        if self.consumer_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_active = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_active {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.consumer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.is_active {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandActiveConsumerChange {
        CommandActiveConsumerChange::new()
    }

    fn default_instance() -> &'static CommandActiveConsumerChange {
        static instance: ::protobuf::rt::LazyV2<CommandActiveConsumerChange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandActiveConsumerChange::new)
    }
}

impl ::protobuf::Clear for CommandActiveConsumerChange {
    fn clear(&mut self) {
        self.consumer_id = ::std::option::Option::None;
        self.is_active = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandActiveConsumerChange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandFlow {
    // message fields
    consumer_id: ::std::option::Option<u64>,
    messagePermits: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandFlow {
    fn default() -> &'a CommandFlow {
        <CommandFlow as ::protobuf::Message>::default_instance()
    }
}

impl CommandFlow {
    pub fn new() -> CommandFlow {
        ::std::default::Default::default()
    }

    // required uint64 consumer_id = 1;


    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }
    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }

    // required uint32 messagePermits = 2;


    pub fn get_messagePermits(&self) -> u32 {
        self.messagePermits.unwrap_or(0)
    }
    pub fn clear_messagePermits(&mut self) {
        self.messagePermits = ::std::option::Option::None;
    }

    pub fn has_messagePermits(&self) -> bool {
        self.messagePermits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messagePermits(&mut self, v: u32) {
        self.messagePermits = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandFlow {
    fn is_initialized(&self) -> bool {
        if self.consumer_id.is_none() {
            return false;
        }
        if self.messagePermits.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.messagePermits = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.messagePermits {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.consumer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.messagePermits {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandFlow {
        CommandFlow::new()
    }

    fn default_instance() -> &'static CommandFlow {
        static instance: ::protobuf::rt::LazyV2<CommandFlow> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandFlow::new)
    }
}

impl ::protobuf::Clear for CommandFlow {
    fn clear(&mut self) {
        self.consumer_id = ::std::option::Option::None;
        self.messagePermits = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandFlow {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandUnsubscribe {
    // message fields
    consumer_id: ::std::option::Option<u64>,
    request_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandUnsubscribe {
    fn default() -> &'a CommandUnsubscribe {
        <CommandUnsubscribe as ::protobuf::Message>::default_instance()
    }
}

impl CommandUnsubscribe {
    pub fn new() -> CommandUnsubscribe {
        ::std::default::Default::default()
    }

    // required uint64 consumer_id = 1;


    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }
    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }

    // required uint64 request_id = 2;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandUnsubscribe {
    fn is_initialized(&self) -> bool {
        if self.consumer_id.is_none() {
            return false;
        }
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.consumer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandUnsubscribe {
        CommandUnsubscribe::new()
    }

    fn default_instance() -> &'static CommandUnsubscribe {
        static instance: ::protobuf::rt::LazyV2<CommandUnsubscribe> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandUnsubscribe::new)
    }
}

impl ::protobuf::Clear for CommandUnsubscribe {
    fn clear(&mut self) {
        self.consumer_id = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandUnsubscribe {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandSeek {
    // message fields
    consumer_id: ::std::option::Option<u64>,
    request_id: ::std::option::Option<u64>,
    pub message_id: ::protobuf::SingularPtrField<MessageIdData>,
    message_publish_time: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandSeek {
    fn default() -> &'a CommandSeek {
        <CommandSeek as ::protobuf::Message>::default_instance()
    }
}

impl CommandSeek {
    pub fn new() -> CommandSeek {
        ::std::default::Default::default()
    }

    // required uint64 consumer_id = 1;


    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }
    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }

    // required uint64 request_id = 2;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional .pulsar.proto.MessageIdData message_id = 3;


    pub fn get_message_id(&self) -> &MessageIdData {
        self.message_id.as_ref().unwrap_or_else(|| <MessageIdData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    pub fn has_message_id(&self) -> bool {
        self.message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: MessageIdData) {
        self.message_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut MessageIdData {
        if self.message_id.is_none() {
            self.message_id.set_default();
        }
        self.message_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_id(&mut self) -> MessageIdData {
        self.message_id.take().unwrap_or_else(|| MessageIdData::new())
    }

    // optional uint64 message_publish_time = 4;


    pub fn get_message_publish_time(&self) -> u64 {
        self.message_publish_time.unwrap_or(0)
    }
    pub fn clear_message_publish_time(&mut self) {
        self.message_publish_time = ::std::option::Option::None;
    }

    pub fn has_message_publish_time(&self) -> bool {
        self.message_publish_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_publish_time(&mut self, v: u64) {
        self.message_publish_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandSeek {
    fn is_initialized(&self) -> bool {
        if self.consumer_id.is_none() {
            return false;
        }
        if self.request_id.is_none() {
            return false;
        }
        for v in &self.message_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.message_publish_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.message_publish_time {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.consumer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.message_id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.message_publish_time {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandSeek {
        CommandSeek::new()
    }

    fn default_instance() -> &'static CommandSeek {
        static instance: ::protobuf::rt::LazyV2<CommandSeek> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandSeek::new)
    }
}

impl ::protobuf::Clear for CommandSeek {
    fn clear(&mut self) {
        self.consumer_id = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.message_id.clear();
        self.message_publish_time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandSeek {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandReachedEndOfTopic {
    // message fields
    consumer_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandReachedEndOfTopic {
    fn default() -> &'a CommandReachedEndOfTopic {
        <CommandReachedEndOfTopic as ::protobuf::Message>::default_instance()
    }
}

impl CommandReachedEndOfTopic {
    pub fn new() -> CommandReachedEndOfTopic {
        ::std::default::Default::default()
    }

    // required uint64 consumer_id = 1;


    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }
    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandReachedEndOfTopic {
    fn is_initialized(&self) -> bool {
        if self.consumer_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.consumer_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandReachedEndOfTopic {
        CommandReachedEndOfTopic::new()
    }

    fn default_instance() -> &'static CommandReachedEndOfTopic {
        static instance: ::protobuf::rt::LazyV2<CommandReachedEndOfTopic> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandReachedEndOfTopic::new)
    }
}

impl ::protobuf::Clear for CommandReachedEndOfTopic {
    fn clear(&mut self) {
        self.consumer_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandReachedEndOfTopic {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandCloseProducer {
    // message fields
    producer_id: ::std::option::Option<u64>,
    request_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandCloseProducer {
    fn default() -> &'a CommandCloseProducer {
        <CommandCloseProducer as ::protobuf::Message>::default_instance()
    }
}

impl CommandCloseProducer {
    pub fn new() -> CommandCloseProducer {
        ::std::default::Default::default()
    }

    // required uint64 producer_id = 1;


    pub fn get_producer_id(&self) -> u64 {
        self.producer_id.unwrap_or(0)
    }
    pub fn clear_producer_id(&mut self) {
        self.producer_id = ::std::option::Option::None;
    }

    pub fn has_producer_id(&self) -> bool {
        self.producer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_id(&mut self, v: u64) {
        self.producer_id = ::std::option::Option::Some(v);
    }

    // required uint64 request_id = 2;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandCloseProducer {
    fn is_initialized(&self) -> bool {
        if self.producer_id.is_none() {
            return false;
        }
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.producer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.producer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.producer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandCloseProducer {
        CommandCloseProducer::new()
    }

    fn default_instance() -> &'static CommandCloseProducer {
        static instance: ::protobuf::rt::LazyV2<CommandCloseProducer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandCloseProducer::new)
    }
}

impl ::protobuf::Clear for CommandCloseProducer {
    fn clear(&mut self) {
        self.producer_id = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandCloseProducer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandCloseConsumer {
    // message fields
    consumer_id: ::std::option::Option<u64>,
    request_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandCloseConsumer {
    fn default() -> &'a CommandCloseConsumer {
        <CommandCloseConsumer as ::protobuf::Message>::default_instance()
    }
}

impl CommandCloseConsumer {
    pub fn new() -> CommandCloseConsumer {
        ::std::default::Default::default()
    }

    // required uint64 consumer_id = 1;


    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }
    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }

    // required uint64 request_id = 2;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandCloseConsumer {
    fn is_initialized(&self) -> bool {
        if self.consumer_id.is_none() {
            return false;
        }
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.consumer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandCloseConsumer {
        CommandCloseConsumer::new()
    }

    fn default_instance() -> &'static CommandCloseConsumer {
        static instance: ::protobuf::rt::LazyV2<CommandCloseConsumer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandCloseConsumer::new)
    }
}

impl ::protobuf::Clear for CommandCloseConsumer {
    fn clear(&mut self) {
        self.consumer_id = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandCloseConsumer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandRedeliverUnacknowledgedMessages {
    // message fields
    consumer_id: ::std::option::Option<u64>,
    pub message_ids: ::protobuf::RepeatedField<MessageIdData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandRedeliverUnacknowledgedMessages {
    fn default() -> &'a CommandRedeliverUnacknowledgedMessages {
        <CommandRedeliverUnacknowledgedMessages as ::protobuf::Message>::default_instance()
    }
}

impl CommandRedeliverUnacknowledgedMessages {
    pub fn new() -> CommandRedeliverUnacknowledgedMessages {
        ::std::default::Default::default()
    }

    // required uint64 consumer_id = 1;


    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }
    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }

    // repeated .pulsar.proto.MessageIdData message_ids = 2;


    pub fn get_message_ids(&self) -> &[MessageIdData] {
        &self.message_ids
    }
    pub fn clear_message_ids(&mut self) {
        self.message_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_ids(&mut self, v: ::protobuf::RepeatedField<MessageIdData>) {
        self.message_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_message_ids(&mut self) -> &mut ::protobuf::RepeatedField<MessageIdData> {
        &mut self.message_ids
    }

    // Take field
    pub fn take_message_ids(&mut self) -> ::protobuf::RepeatedField<MessageIdData> {
        ::std::mem::replace(&mut self.message_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CommandRedeliverUnacknowledgedMessages {
    fn is_initialized(&self) -> bool {
        if self.consumer_id.is_none() {
            return false;
        }
        for v in &self.message_ids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.message_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.message_ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.consumer_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.message_ids {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandRedeliverUnacknowledgedMessages {
        CommandRedeliverUnacknowledgedMessages::new()
    }

    fn default_instance() -> &'static CommandRedeliverUnacknowledgedMessages {
        static instance: ::protobuf::rt::LazyV2<CommandRedeliverUnacknowledgedMessages> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandRedeliverUnacknowledgedMessages::new)
    }
}

impl ::protobuf::Clear for CommandRedeliverUnacknowledgedMessages {
    fn clear(&mut self) {
        self.consumer_id = ::std::option::Option::None;
        self.message_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandRedeliverUnacknowledgedMessages {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandSuccess {
    // message fields
    request_id: ::std::option::Option<u64>,
    pub schema: ::protobuf::SingularPtrField<Schema>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandSuccess {
    fn default() -> &'a CommandSuccess {
        <CommandSuccess as ::protobuf::Message>::default_instance()
    }
}

impl CommandSuccess {
    pub fn new() -> CommandSuccess {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional .pulsar.proto.Schema schema = 2;


    pub fn get_schema(&self) -> &Schema {
        self.schema.as_ref().unwrap_or_else(|| <Schema as ::protobuf::Message>::default_instance())
    }
    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: Schema) {
        self.schema = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut Schema {
        if self.schema.is_none() {
            self.schema.set_default();
        }
        self.schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema(&mut self) -> Schema {
        self.schema.take().unwrap_or_else(|| Schema::new())
    }
}

impl ::protobuf::Message for CommandSuccess {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        for v in &self.schema {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.schema)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.schema.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.schema.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandSuccess {
        CommandSuccess::new()
    }

    fn default_instance() -> &'static CommandSuccess {
        static instance: ::protobuf::rt::LazyV2<CommandSuccess> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandSuccess::new)
    }
}

impl ::protobuf::Clear for CommandSuccess {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.schema.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandSuccess {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandProducerSuccess {
    // message fields
    request_id: ::std::option::Option<u64>,
    producer_name: ::protobuf::SingularField<::std::string::String>,
    last_sequence_id: ::std::option::Option<i64>,
    schema_version: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    topic_epoch: ::std::option::Option<u64>,
    producer_ready: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandProducerSuccess {
    fn default() -> &'a CommandProducerSuccess {
        <CommandProducerSuccess as ::protobuf::Message>::default_instance()
    }
}

impl CommandProducerSuccess {
    pub fn new() -> CommandProducerSuccess {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // required string producer_name = 2;


    pub fn get_producer_name(&self) -> &str {
        match self.producer_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_producer_name(&mut self) {
        self.producer_name.clear();
    }

    pub fn has_producer_name(&self) -> bool {
        self.producer_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_name(&mut self, v: ::std::string::String) {
        self.producer_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_producer_name(&mut self) -> &mut ::std::string::String {
        if self.producer_name.is_none() {
            self.producer_name.set_default();
        }
        self.producer_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_producer_name(&mut self) -> ::std::string::String {
        self.producer_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 last_sequence_id = 3;


    pub fn get_last_sequence_id(&self) -> i64 {
        self.last_sequence_id.unwrap_or(-1i64)
    }
    pub fn clear_last_sequence_id(&mut self) {
        self.last_sequence_id = ::std::option::Option::None;
    }

    pub fn has_last_sequence_id(&self) -> bool {
        self.last_sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_sequence_id(&mut self, v: i64) {
        self.last_sequence_id = ::std::option::Option::Some(v);
    }

    // optional bytes schema_version = 4;


    pub fn get_schema_version(&self) -> &[u8] {
        match self.schema_version.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_schema_version(&mut self) {
        self.schema_version.clear();
    }

    pub fn has_schema_version(&self) -> bool {
        self.schema_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema_version(&mut self, v: ::std::vec::Vec<u8>) {
        self.schema_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema_version(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.schema_version.is_none() {
            self.schema_version.set_default();
        }
        self.schema_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema_version(&mut self) -> ::std::vec::Vec<u8> {
        self.schema_version.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 topic_epoch = 5;


    pub fn get_topic_epoch(&self) -> u64 {
        self.topic_epoch.unwrap_or(0)
    }
    pub fn clear_topic_epoch(&mut self) {
        self.topic_epoch = ::std::option::Option::None;
    }

    pub fn has_topic_epoch(&self) -> bool {
        self.topic_epoch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topic_epoch(&mut self, v: u64) {
        self.topic_epoch = ::std::option::Option::Some(v);
    }

    // optional bool producer_ready = 6;


    pub fn get_producer_ready(&self) -> bool {
        self.producer_ready.unwrap_or(true)
    }
    pub fn clear_producer_ready(&mut self) {
        self.producer_ready = ::std::option::Option::None;
    }

    pub fn has_producer_ready(&self) -> bool {
        self.producer_ready.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_ready(&mut self, v: bool) {
        self.producer_ready = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandProducerSuccess {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        if self.producer_name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.producer_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_sequence_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.schema_version)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.topic_epoch = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.producer_ready = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.producer_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.last_sequence_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.schema_version.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.topic_epoch {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.producer_ready {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.producer_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.last_sequence_id {
            os.write_int64(3, v)?;
        }
        if let Some(ref v) = self.schema_version.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.topic_epoch {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.producer_ready {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandProducerSuccess {
        CommandProducerSuccess::new()
    }

    fn default_instance() -> &'static CommandProducerSuccess {
        static instance: ::protobuf::rt::LazyV2<CommandProducerSuccess> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandProducerSuccess::new)
    }
}

impl ::protobuf::Clear for CommandProducerSuccess {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.producer_name.clear();
        self.last_sequence_id = ::std::option::Option::None;
        self.schema_version.clear();
        self.topic_epoch = ::std::option::Option::None;
        self.producer_ready = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandProducerSuccess {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandError {
    // message fields
    request_id: ::std::option::Option<u64>,
    error: ::std::option::Option<ServerError>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandError {
    fn default() -> &'a CommandError {
        <CommandError as ::protobuf::Message>::default_instance()
    }
}

impl CommandError {
    pub fn new() -> CommandError {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // required .pulsar.proto.ServerError error = 2;


    pub fn get_error(&self) -> ServerError {
        self.error.unwrap_or(ServerError::UnknownError)
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ServerError) {
        self.error = ::std::option::Option::Some(v);
    }

    // required string message = 3;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CommandError {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        if self.error.is_none() {
            return false;
        }
        if self.message.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.error {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandError {
        CommandError::new()
    }

    fn default_instance() -> &'static CommandError {
        static instance: ::protobuf::rt::LazyV2<CommandError> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandError::new)
    }
}

impl ::protobuf::Clear for CommandError {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandError {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandPing {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandPing {
    fn default() -> &'a CommandPing {
        <CommandPing as ::protobuf::Message>::default_instance()
    }
}

impl CommandPing {
    pub fn new() -> CommandPing {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CommandPing {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandPing {
        CommandPing::new()
    }

    fn default_instance() -> &'static CommandPing {
        static instance: ::protobuf::rt::LazyV2<CommandPing> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandPing::new)
    }
}

impl ::protobuf::Clear for CommandPing {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandPing {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandPong {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandPong {
    fn default() -> &'a CommandPong {
        <CommandPong as ::protobuf::Message>::default_instance()
    }
}

impl CommandPong {
    pub fn new() -> CommandPong {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CommandPong {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandPong {
        CommandPong::new()
    }

    fn default_instance() -> &'static CommandPong {
        static instance: ::protobuf::rt::LazyV2<CommandPong> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandPong::new)
    }
}

impl ::protobuf::Clear for CommandPong {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandPong {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandConsumerStats {
    // message fields
    request_id: ::std::option::Option<u64>,
    consumer_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandConsumerStats {
    fn default() -> &'a CommandConsumerStats {
        <CommandConsumerStats as ::protobuf::Message>::default_instance()
    }
}

impl CommandConsumerStats {
    pub fn new() -> CommandConsumerStats {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // required uint64 consumer_id = 4;


    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }
    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandConsumerStats {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        if self.consumer_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.consumer_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandConsumerStats {
        CommandConsumerStats::new()
    }

    fn default_instance() -> &'static CommandConsumerStats {
        static instance: ::protobuf::rt::LazyV2<CommandConsumerStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandConsumerStats::new)
    }
}

impl ::protobuf::Clear for CommandConsumerStats {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.consumer_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandConsumerStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandConsumerStatsResponse {
    // message fields
    request_id: ::std::option::Option<u64>,
    error_code: ::std::option::Option<ServerError>,
    error_message: ::protobuf::SingularField<::std::string::String>,
    msgRateOut: ::std::option::Option<f64>,
    msgThroughputOut: ::std::option::Option<f64>,
    msgRateRedeliver: ::std::option::Option<f64>,
    consumerName: ::protobuf::SingularField<::std::string::String>,
    availablePermits: ::std::option::Option<u64>,
    unackedMessages: ::std::option::Option<u64>,
    blockedConsumerOnUnackedMsgs: ::std::option::Option<bool>,
    address: ::protobuf::SingularField<::std::string::String>,
    connectedSince: ::protobuf::SingularField<::std::string::String>,
    field_type: ::protobuf::SingularField<::std::string::String>,
    msgRateExpired: ::std::option::Option<f64>,
    msgBacklog: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandConsumerStatsResponse {
    fn default() -> &'a CommandConsumerStatsResponse {
        <CommandConsumerStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommandConsumerStatsResponse {
    pub fn new() -> CommandConsumerStatsResponse {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional .pulsar.proto.ServerError error_code = 2;


    pub fn get_error_code(&self) -> ServerError {
        self.error_code.unwrap_or(ServerError::UnknownError)
    }
    pub fn clear_error_code(&mut self) {
        self.error_code = ::std::option::Option::None;
    }

    pub fn has_error_code(&self) -> bool {
        self.error_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_code(&mut self, v: ServerError) {
        self.error_code = ::std::option::Option::Some(v);
    }

    // optional string error_message = 3;


    pub fn get_error_message(&self) -> &str {
        match self.error_message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error_message(&mut self) {
        self.error_message.clear();
    }

    pub fn has_error_message(&self) -> bool {
        self.error_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        if self.error_message.is_none() {
            self.error_message.set_default();
        }
        self.error_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        self.error_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional double msgRateOut = 4;


    pub fn get_msgRateOut(&self) -> f64 {
        self.msgRateOut.unwrap_or(0.)
    }
    pub fn clear_msgRateOut(&mut self) {
        self.msgRateOut = ::std::option::Option::None;
    }

    pub fn has_msgRateOut(&self) -> bool {
        self.msgRateOut.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgRateOut(&mut self, v: f64) {
        self.msgRateOut = ::std::option::Option::Some(v);
    }

    // optional double msgThroughputOut = 5;


    pub fn get_msgThroughputOut(&self) -> f64 {
        self.msgThroughputOut.unwrap_or(0.)
    }
    pub fn clear_msgThroughputOut(&mut self) {
        self.msgThroughputOut = ::std::option::Option::None;
    }

    pub fn has_msgThroughputOut(&self) -> bool {
        self.msgThroughputOut.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgThroughputOut(&mut self, v: f64) {
        self.msgThroughputOut = ::std::option::Option::Some(v);
    }

    // optional double msgRateRedeliver = 6;


    pub fn get_msgRateRedeliver(&self) -> f64 {
        self.msgRateRedeliver.unwrap_or(0.)
    }
    pub fn clear_msgRateRedeliver(&mut self) {
        self.msgRateRedeliver = ::std::option::Option::None;
    }

    pub fn has_msgRateRedeliver(&self) -> bool {
        self.msgRateRedeliver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgRateRedeliver(&mut self, v: f64) {
        self.msgRateRedeliver = ::std::option::Option::Some(v);
    }

    // optional string consumerName = 7;


    pub fn get_consumerName(&self) -> &str {
        match self.consumerName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_consumerName(&mut self) {
        self.consumerName.clear();
    }

    pub fn has_consumerName(&self) -> bool {
        self.consumerName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumerName(&mut self, v: ::std::string::String) {
        self.consumerName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumerName(&mut self) -> &mut ::std::string::String {
        if self.consumerName.is_none() {
            self.consumerName.set_default();
        }
        self.consumerName.as_mut().unwrap()
    }

    // Take field
    pub fn take_consumerName(&mut self) -> ::std::string::String {
        self.consumerName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 availablePermits = 8;


    pub fn get_availablePermits(&self) -> u64 {
        self.availablePermits.unwrap_or(0)
    }
    pub fn clear_availablePermits(&mut self) {
        self.availablePermits = ::std::option::Option::None;
    }

    pub fn has_availablePermits(&self) -> bool {
        self.availablePermits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_availablePermits(&mut self, v: u64) {
        self.availablePermits = ::std::option::Option::Some(v);
    }

    // optional uint64 unackedMessages = 9;


    pub fn get_unackedMessages(&self) -> u64 {
        self.unackedMessages.unwrap_or(0)
    }
    pub fn clear_unackedMessages(&mut self) {
        self.unackedMessages = ::std::option::Option::None;
    }

    pub fn has_unackedMessages(&self) -> bool {
        self.unackedMessages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unackedMessages(&mut self, v: u64) {
        self.unackedMessages = ::std::option::Option::Some(v);
    }

    // optional bool blockedConsumerOnUnackedMsgs = 10;


    pub fn get_blockedConsumerOnUnackedMsgs(&self) -> bool {
        self.blockedConsumerOnUnackedMsgs.unwrap_or(false)
    }
    pub fn clear_blockedConsumerOnUnackedMsgs(&mut self) {
        self.blockedConsumerOnUnackedMsgs = ::std::option::Option::None;
    }

    pub fn has_blockedConsumerOnUnackedMsgs(&self) -> bool {
        self.blockedConsumerOnUnackedMsgs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockedConsumerOnUnackedMsgs(&mut self, v: bool) {
        self.blockedConsumerOnUnackedMsgs = ::std::option::Option::Some(v);
    }

    // optional string address = 11;


    pub fn get_address(&self) -> &str {
        match self.address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        self.address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string connectedSince = 12;


    pub fn get_connectedSince(&self) -> &str {
        match self.connectedSince.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_connectedSince(&mut self) {
        self.connectedSince.clear();
    }

    pub fn has_connectedSince(&self) -> bool {
        self.connectedSince.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connectedSince(&mut self, v: ::std::string::String) {
        self.connectedSince = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connectedSince(&mut self) -> &mut ::std::string::String {
        if self.connectedSince.is_none() {
            self.connectedSince.set_default();
        }
        self.connectedSince.as_mut().unwrap()
    }

    // Take field
    pub fn take_connectedSince(&mut self) -> ::std::string::String {
        self.connectedSince.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string type = 13;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional double msgRateExpired = 14;


    pub fn get_msgRateExpired(&self) -> f64 {
        self.msgRateExpired.unwrap_or(0.)
    }
    pub fn clear_msgRateExpired(&mut self) {
        self.msgRateExpired = ::std::option::Option::None;
    }

    pub fn has_msgRateExpired(&self) -> bool {
        self.msgRateExpired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgRateExpired(&mut self, v: f64) {
        self.msgRateExpired = ::std::option::Option::Some(v);
    }

    // optional uint64 msgBacklog = 15;


    pub fn get_msgBacklog(&self) -> u64 {
        self.msgBacklog.unwrap_or(0)
    }
    pub fn clear_msgBacklog(&mut self) {
        self.msgBacklog = ::std::option::Option::None;
    }

    pub fn has_msgBacklog(&self) -> bool {
        self.msgBacklog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgBacklog(&mut self, v: u64) {
        self.msgBacklog = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandConsumerStatsResponse {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error_code, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error_message)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.msgRateOut = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.msgThroughputOut = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.msgRateRedeliver = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.consumerName)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.availablePermits = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.unackedMessages = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.blockedConsumerOnUnackedMsgs = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.connectedSince)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.msgRateExpired = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.msgBacklog = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.error_code {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.error_message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.msgRateOut {
            my_size += 9;
        }
        if let Some(v) = self.msgThroughputOut {
            my_size += 9;
        }
        if let Some(v) = self.msgRateRedeliver {
            my_size += 9;
        }
        if let Some(ref v) = self.consumerName.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.availablePermits {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.unackedMessages {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blockedConsumerOnUnackedMsgs {
            my_size += 2;
        }
        if let Some(ref v) = self.address.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.connectedSince.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.msgRateExpired {
            my_size += 9;
        }
        if let Some(v) = self.msgBacklog {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.error_code {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.error_message.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.msgRateOut {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.msgThroughputOut {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.msgRateRedeliver {
            os.write_double(6, v)?;
        }
        if let Some(ref v) = self.consumerName.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.availablePermits {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.unackedMessages {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.blockedConsumerOnUnackedMsgs {
            os.write_bool(10, v)?;
        }
        if let Some(ref v) = self.address.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.connectedSince.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(v) = self.msgRateExpired {
            os.write_double(14, v)?;
        }
        if let Some(v) = self.msgBacklog {
            os.write_uint64(15, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandConsumerStatsResponse {
        CommandConsumerStatsResponse::new()
    }

    fn default_instance() -> &'static CommandConsumerStatsResponse {
        static instance: ::protobuf::rt::LazyV2<CommandConsumerStatsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandConsumerStatsResponse::new)
    }
}

impl ::protobuf::Clear for CommandConsumerStatsResponse {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.error_code = ::std::option::Option::None;
        self.error_message.clear();
        self.msgRateOut = ::std::option::Option::None;
        self.msgThroughputOut = ::std::option::Option::None;
        self.msgRateRedeliver = ::std::option::Option::None;
        self.consumerName.clear();
        self.availablePermits = ::std::option::Option::None;
        self.unackedMessages = ::std::option::Option::None;
        self.blockedConsumerOnUnackedMsgs = ::std::option::Option::None;
        self.address.clear();
        self.connectedSince.clear();
        self.field_type.clear();
        self.msgRateExpired = ::std::option::Option::None;
        self.msgBacklog = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandConsumerStatsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandGetLastMessageId {
    // message fields
    consumer_id: ::std::option::Option<u64>,
    request_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandGetLastMessageId {
    fn default() -> &'a CommandGetLastMessageId {
        <CommandGetLastMessageId as ::protobuf::Message>::default_instance()
    }
}

impl CommandGetLastMessageId {
    pub fn new() -> CommandGetLastMessageId {
        ::std::default::Default::default()
    }

    // required uint64 consumer_id = 1;


    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }
    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }

    // required uint64 request_id = 2;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandGetLastMessageId {
    fn is_initialized(&self) -> bool {
        if self.consumer_id.is_none() {
            return false;
        }
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.consumer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandGetLastMessageId {
        CommandGetLastMessageId::new()
    }

    fn default_instance() -> &'static CommandGetLastMessageId {
        static instance: ::protobuf::rt::LazyV2<CommandGetLastMessageId> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandGetLastMessageId::new)
    }
}

impl ::protobuf::Clear for CommandGetLastMessageId {
    fn clear(&mut self) {
        self.consumer_id = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetLastMessageId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandGetLastMessageIdResponse {
    // message fields
    pub last_message_id: ::protobuf::SingularPtrField<MessageIdData>,
    request_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandGetLastMessageIdResponse {
    fn default() -> &'a CommandGetLastMessageIdResponse {
        <CommandGetLastMessageIdResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommandGetLastMessageIdResponse {
    pub fn new() -> CommandGetLastMessageIdResponse {
        ::std::default::Default::default()
    }

    // required .pulsar.proto.MessageIdData last_message_id = 1;


    pub fn get_last_message_id(&self) -> &MessageIdData {
        self.last_message_id.as_ref().unwrap_or_else(|| <MessageIdData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last_message_id(&mut self) {
        self.last_message_id.clear();
    }

    pub fn has_last_message_id(&self) -> bool {
        self.last_message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_message_id(&mut self, v: MessageIdData) {
        self.last_message_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_message_id(&mut self) -> &mut MessageIdData {
        if self.last_message_id.is_none() {
            self.last_message_id.set_default();
        }
        self.last_message_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_message_id(&mut self) -> MessageIdData {
        self.last_message_id.take().unwrap_or_else(|| MessageIdData::new())
    }

    // required uint64 request_id = 2;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandGetLastMessageIdResponse {
    fn is_initialized(&self) -> bool {
        if self.last_message_id.is_none() {
            return false;
        }
        if self.request_id.is_none() {
            return false;
        }
        for v in &self.last_message_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_message_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.last_message_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.last_message_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandGetLastMessageIdResponse {
        CommandGetLastMessageIdResponse::new()
    }

    fn default_instance() -> &'static CommandGetLastMessageIdResponse {
        static instance: ::protobuf::rt::LazyV2<CommandGetLastMessageIdResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandGetLastMessageIdResponse::new)
    }
}

impl ::protobuf::Clear for CommandGetLastMessageIdResponse {
    fn clear(&mut self) {
        self.last_message_id.clear();
        self.request_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetLastMessageIdResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandGetTopicsOfNamespace {
    // message fields
    request_id: ::std::option::Option<u64>,
    namespace: ::protobuf::SingularField<::std::string::String>,
    mode: ::std::option::Option<CommandGetTopicsOfNamespace_Mode>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandGetTopicsOfNamespace {
    fn default() -> &'a CommandGetTopicsOfNamespace {
        <CommandGetTopicsOfNamespace as ::protobuf::Message>::default_instance()
    }
}

impl CommandGetTopicsOfNamespace {
    pub fn new() -> CommandGetTopicsOfNamespace {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // required string namespace = 2;


    pub fn get_namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace.set_default();
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .pulsar.proto.CommandGetTopicsOfNamespace.Mode mode = 3;


    pub fn get_mode(&self) -> CommandGetTopicsOfNamespace_Mode {
        self.mode.unwrap_or(CommandGetTopicsOfNamespace_Mode::PERSISTENT)
    }
    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: CommandGetTopicsOfNamespace_Mode) {
        self.mode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandGetTopicsOfNamespace {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        if self.namespace.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.namespace)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.namespace.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.mode {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandGetTopicsOfNamespace {
        CommandGetTopicsOfNamespace::new()
    }

    fn default_instance() -> &'static CommandGetTopicsOfNamespace {
        static instance: ::protobuf::rt::LazyV2<CommandGetTopicsOfNamespace> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandGetTopicsOfNamespace::new)
    }
}

impl ::protobuf::Clear for CommandGetTopicsOfNamespace {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.namespace.clear();
        self.mode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetTopicsOfNamespace {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommandGetTopicsOfNamespace_Mode {
    PERSISTENT = 0,
    NON_PERSISTENT = 1,
    ALL = 2,
}

impl ::protobuf::ProtobufEnum for CommandGetTopicsOfNamespace_Mode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommandGetTopicsOfNamespace_Mode> {
        match value {
            0 => ::std::option::Option::Some(CommandGetTopicsOfNamespace_Mode::PERSISTENT),
            1 => ::std::option::Option::Some(CommandGetTopicsOfNamespace_Mode::NON_PERSISTENT),
            2 => ::std::option::Option::Some(CommandGetTopicsOfNamespace_Mode::ALL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommandGetTopicsOfNamespace_Mode] = &[
            CommandGetTopicsOfNamespace_Mode::PERSISTENT,
            CommandGetTopicsOfNamespace_Mode::NON_PERSISTENT,
            CommandGetTopicsOfNamespace_Mode::ALL,
        ];
        values
    }
}

impl ::std::marker::Copy for CommandGetTopicsOfNamespace_Mode {
}

impl ::std::default::Default for CommandGetTopicsOfNamespace_Mode {
    fn default() -> Self {
        CommandGetTopicsOfNamespace_Mode::PERSISTENT
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetTopicsOfNamespace_Mode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandGetTopicsOfNamespaceResponse {
    // message fields
    request_id: ::std::option::Option<u64>,
    pub topics: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandGetTopicsOfNamespaceResponse {
    fn default() -> &'a CommandGetTopicsOfNamespaceResponse {
        <CommandGetTopicsOfNamespaceResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommandGetTopicsOfNamespaceResponse {
    pub fn new() -> CommandGetTopicsOfNamespaceResponse {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // repeated string topics = 2;


    pub fn get_topics(&self) -> &[::std::string::String] {
        &self.topics
    }
    pub fn clear_topics(&mut self) {
        self.topics.clear();
    }

    // Param is passed by value, moved
    pub fn set_topics(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.topics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_topics(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.topics
    }

    // Take field
    pub fn take_topics(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.topics, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CommandGetTopicsOfNamespaceResponse {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.topics)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.topics {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.topics {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandGetTopicsOfNamespaceResponse {
        CommandGetTopicsOfNamespaceResponse::new()
    }

    fn default_instance() -> &'static CommandGetTopicsOfNamespaceResponse {
        static instance: ::protobuf::rt::LazyV2<CommandGetTopicsOfNamespaceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandGetTopicsOfNamespaceResponse::new)
    }
}

impl ::protobuf::Clear for CommandGetTopicsOfNamespaceResponse {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.topics.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetTopicsOfNamespaceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandGetSchema {
    // message fields
    request_id: ::std::option::Option<u64>,
    topic: ::protobuf::SingularField<::std::string::String>,
    schema_version: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandGetSchema {
    fn default() -> &'a CommandGetSchema {
        <CommandGetSchema as ::protobuf::Message>::default_instance()
    }
}

impl CommandGetSchema {
    pub fn new() -> CommandGetSchema {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // required string topic = 2;


    pub fn get_topic(&self) -> &str {
        match self.topic.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    pub fn has_topic(&self) -> bool {
        self.topic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        if self.topic.is_none() {
            self.topic.set_default();
        }
        self.topic.as_mut().unwrap()
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        self.topic.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes schema_version = 3;


    pub fn get_schema_version(&self) -> &[u8] {
        match self.schema_version.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_schema_version(&mut self) {
        self.schema_version.clear();
    }

    pub fn has_schema_version(&self) -> bool {
        self.schema_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema_version(&mut self, v: ::std::vec::Vec<u8>) {
        self.schema_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema_version(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.schema_version.is_none() {
            self.schema_version.set_default();
        }
        self.schema_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema_version(&mut self) -> ::std::vec::Vec<u8> {
        self.schema_version.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CommandGetSchema {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        if self.topic.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.topic)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.schema_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.topic.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.schema_version.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.topic.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.schema_version.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandGetSchema {
        CommandGetSchema::new()
    }

    fn default_instance() -> &'static CommandGetSchema {
        static instance: ::protobuf::rt::LazyV2<CommandGetSchema> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandGetSchema::new)
    }
}

impl ::protobuf::Clear for CommandGetSchema {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.topic.clear();
        self.schema_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetSchema {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandGetSchemaResponse {
    // message fields
    request_id: ::std::option::Option<u64>,
    error_code: ::std::option::Option<ServerError>,
    error_message: ::protobuf::SingularField<::std::string::String>,
    pub schema: ::protobuf::SingularPtrField<Schema>,
    schema_version: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandGetSchemaResponse {
    fn default() -> &'a CommandGetSchemaResponse {
        <CommandGetSchemaResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommandGetSchemaResponse {
    pub fn new() -> CommandGetSchemaResponse {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional .pulsar.proto.ServerError error_code = 2;


    pub fn get_error_code(&self) -> ServerError {
        self.error_code.unwrap_or(ServerError::UnknownError)
    }
    pub fn clear_error_code(&mut self) {
        self.error_code = ::std::option::Option::None;
    }

    pub fn has_error_code(&self) -> bool {
        self.error_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_code(&mut self, v: ServerError) {
        self.error_code = ::std::option::Option::Some(v);
    }

    // optional string error_message = 3;


    pub fn get_error_message(&self) -> &str {
        match self.error_message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error_message(&mut self) {
        self.error_message.clear();
    }

    pub fn has_error_message(&self) -> bool {
        self.error_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        if self.error_message.is_none() {
            self.error_message.set_default();
        }
        self.error_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        self.error_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .pulsar.proto.Schema schema = 4;


    pub fn get_schema(&self) -> &Schema {
        self.schema.as_ref().unwrap_or_else(|| <Schema as ::protobuf::Message>::default_instance())
    }
    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: Schema) {
        self.schema = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut Schema {
        if self.schema.is_none() {
            self.schema.set_default();
        }
        self.schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema(&mut self) -> Schema {
        self.schema.take().unwrap_or_else(|| Schema::new())
    }

    // optional bytes schema_version = 5;


    pub fn get_schema_version(&self) -> &[u8] {
        match self.schema_version.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_schema_version(&mut self) {
        self.schema_version.clear();
    }

    pub fn has_schema_version(&self) -> bool {
        self.schema_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema_version(&mut self, v: ::std::vec::Vec<u8>) {
        self.schema_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema_version(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.schema_version.is_none() {
            self.schema_version.set_default();
        }
        self.schema_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema_version(&mut self) -> ::std::vec::Vec<u8> {
        self.schema_version.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CommandGetSchemaResponse {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        for v in &self.schema {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error_code, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error_message)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.schema)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.schema_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.error_code {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.error_message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.schema.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.schema_version.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.error_code {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.error_message.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.schema.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.schema_version.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandGetSchemaResponse {
        CommandGetSchemaResponse::new()
    }

    fn default_instance() -> &'static CommandGetSchemaResponse {
        static instance: ::protobuf::rt::LazyV2<CommandGetSchemaResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandGetSchemaResponse::new)
    }
}

impl ::protobuf::Clear for CommandGetSchemaResponse {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.error_code = ::std::option::Option::None;
        self.error_message.clear();
        self.schema.clear();
        self.schema_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetSchemaResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandGetOrCreateSchema {
    // message fields
    request_id: ::std::option::Option<u64>,
    topic: ::protobuf::SingularField<::std::string::String>,
    pub schema: ::protobuf::SingularPtrField<Schema>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandGetOrCreateSchema {
    fn default() -> &'a CommandGetOrCreateSchema {
        <CommandGetOrCreateSchema as ::protobuf::Message>::default_instance()
    }
}

impl CommandGetOrCreateSchema {
    pub fn new() -> CommandGetOrCreateSchema {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // required string topic = 2;


    pub fn get_topic(&self) -> &str {
        match self.topic.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    pub fn has_topic(&self) -> bool {
        self.topic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        if self.topic.is_none() {
            self.topic.set_default();
        }
        self.topic.as_mut().unwrap()
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        self.topic.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .pulsar.proto.Schema schema = 3;


    pub fn get_schema(&self) -> &Schema {
        self.schema.as_ref().unwrap_or_else(|| <Schema as ::protobuf::Message>::default_instance())
    }
    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: Schema) {
        self.schema = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut Schema {
        if self.schema.is_none() {
            self.schema.set_default();
        }
        self.schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema(&mut self) -> Schema {
        self.schema.take().unwrap_or_else(|| Schema::new())
    }
}

impl ::protobuf::Message for CommandGetOrCreateSchema {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        if self.topic.is_none() {
            return false;
        }
        if self.schema.is_none() {
            return false;
        }
        for v in &self.schema {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.topic)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.schema)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.topic.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.schema.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.topic.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.schema.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandGetOrCreateSchema {
        CommandGetOrCreateSchema::new()
    }

    fn default_instance() -> &'static CommandGetOrCreateSchema {
        static instance: ::protobuf::rt::LazyV2<CommandGetOrCreateSchema> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandGetOrCreateSchema::new)
    }
}

impl ::protobuf::Clear for CommandGetOrCreateSchema {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.topic.clear();
        self.schema.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetOrCreateSchema {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandGetOrCreateSchemaResponse {
    // message fields
    request_id: ::std::option::Option<u64>,
    error_code: ::std::option::Option<ServerError>,
    error_message: ::protobuf::SingularField<::std::string::String>,
    schema_version: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandGetOrCreateSchemaResponse {
    fn default() -> &'a CommandGetOrCreateSchemaResponse {
        <CommandGetOrCreateSchemaResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommandGetOrCreateSchemaResponse {
    pub fn new() -> CommandGetOrCreateSchemaResponse {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional .pulsar.proto.ServerError error_code = 2;


    pub fn get_error_code(&self) -> ServerError {
        self.error_code.unwrap_or(ServerError::UnknownError)
    }
    pub fn clear_error_code(&mut self) {
        self.error_code = ::std::option::Option::None;
    }

    pub fn has_error_code(&self) -> bool {
        self.error_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_code(&mut self, v: ServerError) {
        self.error_code = ::std::option::Option::Some(v);
    }

    // optional string error_message = 3;


    pub fn get_error_message(&self) -> &str {
        match self.error_message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error_message(&mut self) {
        self.error_message.clear();
    }

    pub fn has_error_message(&self) -> bool {
        self.error_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        if self.error_message.is_none() {
            self.error_message.set_default();
        }
        self.error_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        self.error_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes schema_version = 4;


    pub fn get_schema_version(&self) -> &[u8] {
        match self.schema_version.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_schema_version(&mut self) {
        self.schema_version.clear();
    }

    pub fn has_schema_version(&self) -> bool {
        self.schema_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema_version(&mut self, v: ::std::vec::Vec<u8>) {
        self.schema_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema_version(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.schema_version.is_none() {
            self.schema_version.set_default();
        }
        self.schema_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema_version(&mut self) -> ::std::vec::Vec<u8> {
        self.schema_version.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CommandGetOrCreateSchemaResponse {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error_code, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error_message)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.schema_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.error_code {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.error_message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.schema_version.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.error_code {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.error_message.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.schema_version.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandGetOrCreateSchemaResponse {
        CommandGetOrCreateSchemaResponse::new()
    }

    fn default_instance() -> &'static CommandGetOrCreateSchemaResponse {
        static instance: ::protobuf::rt::LazyV2<CommandGetOrCreateSchemaResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandGetOrCreateSchemaResponse::new)
    }
}

impl ::protobuf::Clear for CommandGetOrCreateSchemaResponse {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.error_code = ::std::option::Option::None;
        self.error_message.clear();
        self.schema_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetOrCreateSchemaResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandNewTxn {
    // message fields
    request_id: ::std::option::Option<u64>,
    txn_ttl_seconds: ::std::option::Option<u64>,
    tc_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandNewTxn {
    fn default() -> &'a CommandNewTxn {
        <CommandNewTxn as ::protobuf::Message>::default_instance()
    }
}

impl CommandNewTxn {
    pub fn new() -> CommandNewTxn {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 txn_ttl_seconds = 2;


    pub fn get_txn_ttl_seconds(&self) -> u64 {
        self.txn_ttl_seconds.unwrap_or(0u64)
    }
    pub fn clear_txn_ttl_seconds(&mut self) {
        self.txn_ttl_seconds = ::std::option::Option::None;
    }

    pub fn has_txn_ttl_seconds(&self) -> bool {
        self.txn_ttl_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_ttl_seconds(&mut self, v: u64) {
        self.txn_ttl_seconds = ::std::option::Option::Some(v);
    }

    // optional uint64 tc_id = 3;


    pub fn get_tc_id(&self) -> u64 {
        self.tc_id.unwrap_or(0u64)
    }
    pub fn clear_tc_id(&mut self) {
        self.tc_id = ::std::option::Option::None;
    }

    pub fn has_tc_id(&self) -> bool {
        self.tc_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tc_id(&mut self, v: u64) {
        self.tc_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandNewTxn {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txn_ttl_seconds = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tc_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txn_ttl_seconds {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tc_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.txn_ttl_seconds {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.tc_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandNewTxn {
        CommandNewTxn::new()
    }

    fn default_instance() -> &'static CommandNewTxn {
        static instance: ::protobuf::rt::LazyV2<CommandNewTxn> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandNewTxn::new)
    }
}

impl ::protobuf::Clear for CommandNewTxn {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.txn_ttl_seconds = ::std::option::Option::None;
        self.tc_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandNewTxn {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandNewTxnResponse {
    // message fields
    request_id: ::std::option::Option<u64>,
    txnid_least_bits: ::std::option::Option<u64>,
    txnid_most_bits: ::std::option::Option<u64>,
    error: ::std::option::Option<ServerError>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandNewTxnResponse {
    fn default() -> &'a CommandNewTxnResponse {
        <CommandNewTxnResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommandNewTxnResponse {
    pub fn new() -> CommandNewTxnResponse {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_least_bits = 2;


    pub fn get_txnid_least_bits(&self) -> u64 {
        self.txnid_least_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_least_bits(&mut self) {
        self.txnid_least_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_least_bits(&self) -> bool {
        self.txnid_least_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_least_bits(&mut self, v: u64) {
        self.txnid_least_bits = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_most_bits = 3;


    pub fn get_txnid_most_bits(&self) -> u64 {
        self.txnid_most_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_most_bits(&mut self) {
        self.txnid_most_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_most_bits(&self) -> bool {
        self.txnid_most_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_most_bits(&mut self, v: u64) {
        self.txnid_most_bits = ::std::option::Option::Some(v);
    }

    // optional .pulsar.proto.ServerError error = 4;


    pub fn get_error(&self) -> ServerError {
        self.error.unwrap_or(ServerError::UnknownError)
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ServerError) {
        self.error = ::std::option::Option::Some(v);
    }

    // optional string message = 5;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CommandNewTxnResponse {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_least_bits = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_most_bits = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_least_bits {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_most_bits {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.txnid_least_bits {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.txnid_most_bits {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.error {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandNewTxnResponse {
        CommandNewTxnResponse::new()
    }

    fn default_instance() -> &'static CommandNewTxnResponse {
        static instance: ::protobuf::rt::LazyV2<CommandNewTxnResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandNewTxnResponse::new)
    }
}

impl ::protobuf::Clear for CommandNewTxnResponse {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.txnid_least_bits = ::std::option::Option::None;
        self.txnid_most_bits = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandNewTxnResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandAddPartitionToTxn {
    // message fields
    request_id: ::std::option::Option<u64>,
    txnid_least_bits: ::std::option::Option<u64>,
    txnid_most_bits: ::std::option::Option<u64>,
    pub partitions: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandAddPartitionToTxn {
    fn default() -> &'a CommandAddPartitionToTxn {
        <CommandAddPartitionToTxn as ::protobuf::Message>::default_instance()
    }
}

impl CommandAddPartitionToTxn {
    pub fn new() -> CommandAddPartitionToTxn {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_least_bits = 2;


    pub fn get_txnid_least_bits(&self) -> u64 {
        self.txnid_least_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_least_bits(&mut self) {
        self.txnid_least_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_least_bits(&self) -> bool {
        self.txnid_least_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_least_bits(&mut self, v: u64) {
        self.txnid_least_bits = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_most_bits = 3;


    pub fn get_txnid_most_bits(&self) -> u64 {
        self.txnid_most_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_most_bits(&mut self) {
        self.txnid_most_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_most_bits(&self) -> bool {
        self.txnid_most_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_most_bits(&mut self, v: u64) {
        self.txnid_most_bits = ::std::option::Option::Some(v);
    }

    // repeated string partitions = 4;


    pub fn get_partitions(&self) -> &[::std::string::String] {
        &self.partitions
    }
    pub fn clear_partitions(&mut self) {
        self.partitions.clear();
    }

    // Param is passed by value, moved
    pub fn set_partitions(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.partitions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_partitions(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.partitions
    }

    // Take field
    pub fn take_partitions(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.partitions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CommandAddPartitionToTxn {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_least_bits = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_most_bits = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.partitions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_least_bits {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_most_bits {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.partitions {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.txnid_least_bits {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.txnid_most_bits {
            os.write_uint64(3, v)?;
        }
        for v in &self.partitions {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandAddPartitionToTxn {
        CommandAddPartitionToTxn::new()
    }

    fn default_instance() -> &'static CommandAddPartitionToTxn {
        static instance: ::protobuf::rt::LazyV2<CommandAddPartitionToTxn> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandAddPartitionToTxn::new)
    }
}

impl ::protobuf::Clear for CommandAddPartitionToTxn {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.txnid_least_bits = ::std::option::Option::None;
        self.txnid_most_bits = ::std::option::Option::None;
        self.partitions.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandAddPartitionToTxn {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandAddPartitionToTxnResponse {
    // message fields
    request_id: ::std::option::Option<u64>,
    txnid_least_bits: ::std::option::Option<u64>,
    txnid_most_bits: ::std::option::Option<u64>,
    error: ::std::option::Option<ServerError>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandAddPartitionToTxnResponse {
    fn default() -> &'a CommandAddPartitionToTxnResponse {
        <CommandAddPartitionToTxnResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommandAddPartitionToTxnResponse {
    pub fn new() -> CommandAddPartitionToTxnResponse {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_least_bits = 2;


    pub fn get_txnid_least_bits(&self) -> u64 {
        self.txnid_least_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_least_bits(&mut self) {
        self.txnid_least_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_least_bits(&self) -> bool {
        self.txnid_least_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_least_bits(&mut self, v: u64) {
        self.txnid_least_bits = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_most_bits = 3;


    pub fn get_txnid_most_bits(&self) -> u64 {
        self.txnid_most_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_most_bits(&mut self) {
        self.txnid_most_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_most_bits(&self) -> bool {
        self.txnid_most_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_most_bits(&mut self, v: u64) {
        self.txnid_most_bits = ::std::option::Option::Some(v);
    }

    // optional .pulsar.proto.ServerError error = 4;


    pub fn get_error(&self) -> ServerError {
        self.error.unwrap_or(ServerError::UnknownError)
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ServerError) {
        self.error = ::std::option::Option::Some(v);
    }

    // optional string message = 5;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CommandAddPartitionToTxnResponse {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_least_bits = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_most_bits = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_least_bits {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_most_bits {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.txnid_least_bits {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.txnid_most_bits {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.error {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandAddPartitionToTxnResponse {
        CommandAddPartitionToTxnResponse::new()
    }

    fn default_instance() -> &'static CommandAddPartitionToTxnResponse {
        static instance: ::protobuf::rt::LazyV2<CommandAddPartitionToTxnResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandAddPartitionToTxnResponse::new)
    }
}

impl ::protobuf::Clear for CommandAddPartitionToTxnResponse {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.txnid_least_bits = ::std::option::Option::None;
        self.txnid_most_bits = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandAddPartitionToTxnResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Subscription {
    // message fields
    topic: ::protobuf::SingularField<::std::string::String>,
    subscription: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Subscription {
    fn default() -> &'a Subscription {
        <Subscription as ::protobuf::Message>::default_instance()
    }
}

impl Subscription {
    pub fn new() -> Subscription {
        ::std::default::Default::default()
    }

    // required string topic = 1;


    pub fn get_topic(&self) -> &str {
        match self.topic.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    pub fn has_topic(&self) -> bool {
        self.topic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        if self.topic.is_none() {
            self.topic.set_default();
        }
        self.topic.as_mut().unwrap()
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        self.topic.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string subscription = 2;


    pub fn get_subscription(&self) -> &str {
        match self.subscription.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    pub fn has_subscription(&self) -> bool {
        self.subscription.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: ::std::string::String) {
        self.subscription = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut ::std::string::String {
        if self.subscription.is_none() {
            self.subscription.set_default();
        }
        self.subscription.as_mut().unwrap()
    }

    // Take field
    pub fn take_subscription(&mut self) -> ::std::string::String {
        self.subscription.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Subscription {
    fn is_initialized(&self) -> bool {
        if self.topic.is_none() {
            return false;
        }
        if self.subscription.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.topic)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subscription)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.topic.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.subscription.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.topic.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.subscription.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Subscription {
        Subscription::new()
    }

    fn default_instance() -> &'static Subscription {
        static instance: ::protobuf::rt::LazyV2<Subscription> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Subscription::new)
    }
}

impl ::protobuf::Clear for Subscription {
    fn clear(&mut self) {
        self.topic.clear();
        self.subscription.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Subscription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandAddSubscriptionToTxn {
    // message fields
    request_id: ::std::option::Option<u64>,
    txnid_least_bits: ::std::option::Option<u64>,
    txnid_most_bits: ::std::option::Option<u64>,
    pub subscription: ::protobuf::RepeatedField<Subscription>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandAddSubscriptionToTxn {
    fn default() -> &'a CommandAddSubscriptionToTxn {
        <CommandAddSubscriptionToTxn as ::protobuf::Message>::default_instance()
    }
}

impl CommandAddSubscriptionToTxn {
    pub fn new() -> CommandAddSubscriptionToTxn {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_least_bits = 2;


    pub fn get_txnid_least_bits(&self) -> u64 {
        self.txnid_least_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_least_bits(&mut self) {
        self.txnid_least_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_least_bits(&self) -> bool {
        self.txnid_least_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_least_bits(&mut self, v: u64) {
        self.txnid_least_bits = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_most_bits = 3;


    pub fn get_txnid_most_bits(&self) -> u64 {
        self.txnid_most_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_most_bits(&mut self) {
        self.txnid_most_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_most_bits(&self) -> bool {
        self.txnid_most_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_most_bits(&mut self, v: u64) {
        self.txnid_most_bits = ::std::option::Option::Some(v);
    }

    // repeated .pulsar.proto.Subscription subscription = 4;


    pub fn get_subscription(&self) -> &[Subscription] {
        &self.subscription
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: ::protobuf::RepeatedField<Subscription>) {
        self.subscription = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subscription(&mut self) -> &mut ::protobuf::RepeatedField<Subscription> {
        &mut self.subscription
    }

    // Take field
    pub fn take_subscription(&mut self) -> ::protobuf::RepeatedField<Subscription> {
        ::std::mem::replace(&mut self.subscription, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CommandAddSubscriptionToTxn {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        for v in &self.subscription {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_least_bits = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_most_bits = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subscription)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_least_bits {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_most_bits {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.subscription {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.txnid_least_bits {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.txnid_most_bits {
            os.write_uint64(3, v)?;
        }
        for v in &self.subscription {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandAddSubscriptionToTxn {
        CommandAddSubscriptionToTxn::new()
    }

    fn default_instance() -> &'static CommandAddSubscriptionToTxn {
        static instance: ::protobuf::rt::LazyV2<CommandAddSubscriptionToTxn> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandAddSubscriptionToTxn::new)
    }
}

impl ::protobuf::Clear for CommandAddSubscriptionToTxn {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.txnid_least_bits = ::std::option::Option::None;
        self.txnid_most_bits = ::std::option::Option::None;
        self.subscription.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandAddSubscriptionToTxn {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandAddSubscriptionToTxnResponse {
    // message fields
    request_id: ::std::option::Option<u64>,
    txnid_least_bits: ::std::option::Option<u64>,
    txnid_most_bits: ::std::option::Option<u64>,
    error: ::std::option::Option<ServerError>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandAddSubscriptionToTxnResponse {
    fn default() -> &'a CommandAddSubscriptionToTxnResponse {
        <CommandAddSubscriptionToTxnResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommandAddSubscriptionToTxnResponse {
    pub fn new() -> CommandAddSubscriptionToTxnResponse {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_least_bits = 2;


    pub fn get_txnid_least_bits(&self) -> u64 {
        self.txnid_least_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_least_bits(&mut self) {
        self.txnid_least_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_least_bits(&self) -> bool {
        self.txnid_least_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_least_bits(&mut self, v: u64) {
        self.txnid_least_bits = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_most_bits = 3;


    pub fn get_txnid_most_bits(&self) -> u64 {
        self.txnid_most_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_most_bits(&mut self) {
        self.txnid_most_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_most_bits(&self) -> bool {
        self.txnid_most_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_most_bits(&mut self, v: u64) {
        self.txnid_most_bits = ::std::option::Option::Some(v);
    }

    // optional .pulsar.proto.ServerError error = 4;


    pub fn get_error(&self) -> ServerError {
        self.error.unwrap_or(ServerError::UnknownError)
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ServerError) {
        self.error = ::std::option::Option::Some(v);
    }

    // optional string message = 5;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CommandAddSubscriptionToTxnResponse {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_least_bits = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_most_bits = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_least_bits {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_most_bits {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.txnid_least_bits {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.txnid_most_bits {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.error {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandAddSubscriptionToTxnResponse {
        CommandAddSubscriptionToTxnResponse::new()
    }

    fn default_instance() -> &'static CommandAddSubscriptionToTxnResponse {
        static instance: ::protobuf::rt::LazyV2<CommandAddSubscriptionToTxnResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandAddSubscriptionToTxnResponse::new)
    }
}

impl ::protobuf::Clear for CommandAddSubscriptionToTxnResponse {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.txnid_least_bits = ::std::option::Option::None;
        self.txnid_most_bits = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandAddSubscriptionToTxnResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandEndTxn {
    // message fields
    request_id: ::std::option::Option<u64>,
    txnid_least_bits: ::std::option::Option<u64>,
    txnid_most_bits: ::std::option::Option<u64>,
    txn_action: ::std::option::Option<TxnAction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandEndTxn {
    fn default() -> &'a CommandEndTxn {
        <CommandEndTxn as ::protobuf::Message>::default_instance()
    }
}

impl CommandEndTxn {
    pub fn new() -> CommandEndTxn {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_least_bits = 2;


    pub fn get_txnid_least_bits(&self) -> u64 {
        self.txnid_least_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_least_bits(&mut self) {
        self.txnid_least_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_least_bits(&self) -> bool {
        self.txnid_least_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_least_bits(&mut self, v: u64) {
        self.txnid_least_bits = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_most_bits = 3;


    pub fn get_txnid_most_bits(&self) -> u64 {
        self.txnid_most_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_most_bits(&mut self) {
        self.txnid_most_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_most_bits(&self) -> bool {
        self.txnid_most_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_most_bits(&mut self, v: u64) {
        self.txnid_most_bits = ::std::option::Option::Some(v);
    }

    // optional .pulsar.proto.TxnAction txn_action = 4;


    pub fn get_txn_action(&self) -> TxnAction {
        self.txn_action.unwrap_or(TxnAction::COMMIT)
    }
    pub fn clear_txn_action(&mut self) {
        self.txn_action = ::std::option::Option::None;
    }

    pub fn has_txn_action(&self) -> bool {
        self.txn_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_action(&mut self, v: TxnAction) {
        self.txn_action = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandEndTxn {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_least_bits = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_most_bits = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.txn_action, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_least_bits {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_most_bits {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txn_action {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.txnid_least_bits {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.txnid_most_bits {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.txn_action {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandEndTxn {
        CommandEndTxn::new()
    }

    fn default_instance() -> &'static CommandEndTxn {
        static instance: ::protobuf::rt::LazyV2<CommandEndTxn> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandEndTxn::new)
    }
}

impl ::protobuf::Clear for CommandEndTxn {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.txnid_least_bits = ::std::option::Option::None;
        self.txnid_most_bits = ::std::option::Option::None;
        self.txn_action = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandEndTxn {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandEndTxnResponse {
    // message fields
    request_id: ::std::option::Option<u64>,
    txnid_least_bits: ::std::option::Option<u64>,
    txnid_most_bits: ::std::option::Option<u64>,
    error: ::std::option::Option<ServerError>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandEndTxnResponse {
    fn default() -> &'a CommandEndTxnResponse {
        <CommandEndTxnResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommandEndTxnResponse {
    pub fn new() -> CommandEndTxnResponse {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_least_bits = 2;


    pub fn get_txnid_least_bits(&self) -> u64 {
        self.txnid_least_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_least_bits(&mut self) {
        self.txnid_least_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_least_bits(&self) -> bool {
        self.txnid_least_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_least_bits(&mut self, v: u64) {
        self.txnid_least_bits = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_most_bits = 3;


    pub fn get_txnid_most_bits(&self) -> u64 {
        self.txnid_most_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_most_bits(&mut self) {
        self.txnid_most_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_most_bits(&self) -> bool {
        self.txnid_most_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_most_bits(&mut self, v: u64) {
        self.txnid_most_bits = ::std::option::Option::Some(v);
    }

    // optional .pulsar.proto.ServerError error = 4;


    pub fn get_error(&self) -> ServerError {
        self.error.unwrap_or(ServerError::UnknownError)
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ServerError) {
        self.error = ::std::option::Option::Some(v);
    }

    // optional string message = 5;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CommandEndTxnResponse {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_least_bits = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_most_bits = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_least_bits {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_most_bits {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.txnid_least_bits {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.txnid_most_bits {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.error {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandEndTxnResponse {
        CommandEndTxnResponse::new()
    }

    fn default_instance() -> &'static CommandEndTxnResponse {
        static instance: ::protobuf::rt::LazyV2<CommandEndTxnResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandEndTxnResponse::new)
    }
}

impl ::protobuf::Clear for CommandEndTxnResponse {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.txnid_least_bits = ::std::option::Option::None;
        self.txnid_most_bits = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandEndTxnResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandEndTxnOnPartition {
    // message fields
    request_id: ::std::option::Option<u64>,
    txnid_least_bits: ::std::option::Option<u64>,
    txnid_most_bits: ::std::option::Option<u64>,
    topic: ::protobuf::SingularField<::std::string::String>,
    txn_action: ::std::option::Option<TxnAction>,
    txnid_least_bits_of_low_watermark: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandEndTxnOnPartition {
    fn default() -> &'a CommandEndTxnOnPartition {
        <CommandEndTxnOnPartition as ::protobuf::Message>::default_instance()
    }
}

impl CommandEndTxnOnPartition {
    pub fn new() -> CommandEndTxnOnPartition {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_least_bits = 2;


    pub fn get_txnid_least_bits(&self) -> u64 {
        self.txnid_least_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_least_bits(&mut self) {
        self.txnid_least_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_least_bits(&self) -> bool {
        self.txnid_least_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_least_bits(&mut self, v: u64) {
        self.txnid_least_bits = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_most_bits = 3;


    pub fn get_txnid_most_bits(&self) -> u64 {
        self.txnid_most_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_most_bits(&mut self) {
        self.txnid_most_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_most_bits(&self) -> bool {
        self.txnid_most_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_most_bits(&mut self, v: u64) {
        self.txnid_most_bits = ::std::option::Option::Some(v);
    }

    // optional string topic = 4;


    pub fn get_topic(&self) -> &str {
        match self.topic.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    pub fn has_topic(&self) -> bool {
        self.topic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        if self.topic.is_none() {
            self.topic.set_default();
        }
        self.topic.as_mut().unwrap()
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        self.topic.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .pulsar.proto.TxnAction txn_action = 5;


    pub fn get_txn_action(&self) -> TxnAction {
        self.txn_action.unwrap_or(TxnAction::COMMIT)
    }
    pub fn clear_txn_action(&mut self) {
        self.txn_action = ::std::option::Option::None;
    }

    pub fn has_txn_action(&self) -> bool {
        self.txn_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_action(&mut self, v: TxnAction) {
        self.txn_action = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_least_bits_of_low_watermark = 6;


    pub fn get_txnid_least_bits_of_low_watermark(&self) -> u64 {
        self.txnid_least_bits_of_low_watermark.unwrap_or(0)
    }
    pub fn clear_txnid_least_bits_of_low_watermark(&mut self) {
        self.txnid_least_bits_of_low_watermark = ::std::option::Option::None;
    }

    pub fn has_txnid_least_bits_of_low_watermark(&self) -> bool {
        self.txnid_least_bits_of_low_watermark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_least_bits_of_low_watermark(&mut self, v: u64) {
        self.txnid_least_bits_of_low_watermark = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandEndTxnOnPartition {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_least_bits = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_most_bits = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.topic)?;
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.txn_action, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_least_bits_of_low_watermark = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_least_bits {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_most_bits {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.topic.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.txn_action {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        if let Some(v) = self.txnid_least_bits_of_low_watermark {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.txnid_least_bits {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.txnid_most_bits {
            os.write_uint64(3, v)?;
        }
        if let Some(ref v) = self.topic.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.txn_action {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.txnid_least_bits_of_low_watermark {
            os.write_uint64(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandEndTxnOnPartition {
        CommandEndTxnOnPartition::new()
    }

    fn default_instance() -> &'static CommandEndTxnOnPartition {
        static instance: ::protobuf::rt::LazyV2<CommandEndTxnOnPartition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandEndTxnOnPartition::new)
    }
}

impl ::protobuf::Clear for CommandEndTxnOnPartition {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.txnid_least_bits = ::std::option::Option::None;
        self.txnid_most_bits = ::std::option::Option::None;
        self.topic.clear();
        self.txn_action = ::std::option::Option::None;
        self.txnid_least_bits_of_low_watermark = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandEndTxnOnPartition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandEndTxnOnPartitionResponse {
    // message fields
    request_id: ::std::option::Option<u64>,
    txnid_least_bits: ::std::option::Option<u64>,
    txnid_most_bits: ::std::option::Option<u64>,
    error: ::std::option::Option<ServerError>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandEndTxnOnPartitionResponse {
    fn default() -> &'a CommandEndTxnOnPartitionResponse {
        <CommandEndTxnOnPartitionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommandEndTxnOnPartitionResponse {
    pub fn new() -> CommandEndTxnOnPartitionResponse {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_least_bits = 2;


    pub fn get_txnid_least_bits(&self) -> u64 {
        self.txnid_least_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_least_bits(&mut self) {
        self.txnid_least_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_least_bits(&self) -> bool {
        self.txnid_least_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_least_bits(&mut self, v: u64) {
        self.txnid_least_bits = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_most_bits = 3;


    pub fn get_txnid_most_bits(&self) -> u64 {
        self.txnid_most_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_most_bits(&mut self) {
        self.txnid_most_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_most_bits(&self) -> bool {
        self.txnid_most_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_most_bits(&mut self, v: u64) {
        self.txnid_most_bits = ::std::option::Option::Some(v);
    }

    // optional .pulsar.proto.ServerError error = 4;


    pub fn get_error(&self) -> ServerError {
        self.error.unwrap_or(ServerError::UnknownError)
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ServerError) {
        self.error = ::std::option::Option::Some(v);
    }

    // optional string message = 5;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CommandEndTxnOnPartitionResponse {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_least_bits = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_most_bits = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_least_bits {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_most_bits {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.txnid_least_bits {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.txnid_most_bits {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.error {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandEndTxnOnPartitionResponse {
        CommandEndTxnOnPartitionResponse::new()
    }

    fn default_instance() -> &'static CommandEndTxnOnPartitionResponse {
        static instance: ::protobuf::rt::LazyV2<CommandEndTxnOnPartitionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandEndTxnOnPartitionResponse::new)
    }
}

impl ::protobuf::Clear for CommandEndTxnOnPartitionResponse {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.txnid_least_bits = ::std::option::Option::None;
        self.txnid_most_bits = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandEndTxnOnPartitionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandEndTxnOnSubscription {
    // message fields
    request_id: ::std::option::Option<u64>,
    txnid_least_bits: ::std::option::Option<u64>,
    txnid_most_bits: ::std::option::Option<u64>,
    pub subscription: ::protobuf::SingularPtrField<Subscription>,
    txn_action: ::std::option::Option<TxnAction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandEndTxnOnSubscription {
    fn default() -> &'a CommandEndTxnOnSubscription {
        <CommandEndTxnOnSubscription as ::protobuf::Message>::default_instance()
    }
}

impl CommandEndTxnOnSubscription {
    pub fn new() -> CommandEndTxnOnSubscription {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_least_bits = 2;


    pub fn get_txnid_least_bits(&self) -> u64 {
        self.txnid_least_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_least_bits(&mut self) {
        self.txnid_least_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_least_bits(&self) -> bool {
        self.txnid_least_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_least_bits(&mut self, v: u64) {
        self.txnid_least_bits = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_most_bits = 3;


    pub fn get_txnid_most_bits(&self) -> u64 {
        self.txnid_most_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_most_bits(&mut self) {
        self.txnid_most_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_most_bits(&self) -> bool {
        self.txnid_most_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_most_bits(&mut self, v: u64) {
        self.txnid_most_bits = ::std::option::Option::Some(v);
    }

    // optional .pulsar.proto.Subscription subscription = 4;


    pub fn get_subscription(&self) -> &Subscription {
        self.subscription.as_ref().unwrap_or_else(|| <Subscription as ::protobuf::Message>::default_instance())
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    pub fn has_subscription(&self) -> bool {
        self.subscription.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: Subscription) {
        self.subscription = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut Subscription {
        if self.subscription.is_none() {
            self.subscription.set_default();
        }
        self.subscription.as_mut().unwrap()
    }

    // Take field
    pub fn take_subscription(&mut self) -> Subscription {
        self.subscription.take().unwrap_or_else(|| Subscription::new())
    }

    // optional .pulsar.proto.TxnAction txn_action = 5;


    pub fn get_txn_action(&self) -> TxnAction {
        self.txn_action.unwrap_or(TxnAction::COMMIT)
    }
    pub fn clear_txn_action(&mut self) {
        self.txn_action = ::std::option::Option::None;
    }

    pub fn has_txn_action(&self) -> bool {
        self.txn_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_action(&mut self, v: TxnAction) {
        self.txn_action = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CommandEndTxnOnSubscription {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        for v in &self.subscription {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_least_bits = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_most_bits = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subscription)?;
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.txn_action, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_least_bits {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_most_bits {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.subscription.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.txn_action {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.txnid_least_bits {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.txnid_most_bits {
            os.write_uint64(3, v)?;
        }
        if let Some(ref v) = self.subscription.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.txn_action {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandEndTxnOnSubscription {
        CommandEndTxnOnSubscription::new()
    }

    fn default_instance() -> &'static CommandEndTxnOnSubscription {
        static instance: ::protobuf::rt::LazyV2<CommandEndTxnOnSubscription> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandEndTxnOnSubscription::new)
    }
}

impl ::protobuf::Clear for CommandEndTxnOnSubscription {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.txnid_least_bits = ::std::option::Option::None;
        self.txnid_most_bits = ::std::option::Option::None;
        self.subscription.clear();
        self.txn_action = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandEndTxnOnSubscription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandEndTxnOnSubscriptionResponse {
    // message fields
    request_id: ::std::option::Option<u64>,
    txnid_least_bits: ::std::option::Option<u64>,
    txnid_most_bits: ::std::option::Option<u64>,
    error: ::std::option::Option<ServerError>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandEndTxnOnSubscriptionResponse {
    fn default() -> &'a CommandEndTxnOnSubscriptionResponse {
        <CommandEndTxnOnSubscriptionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommandEndTxnOnSubscriptionResponse {
    pub fn new() -> CommandEndTxnOnSubscriptionResponse {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;


    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_least_bits = 2;


    pub fn get_txnid_least_bits(&self) -> u64 {
        self.txnid_least_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_least_bits(&mut self) {
        self.txnid_least_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_least_bits(&self) -> bool {
        self.txnid_least_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_least_bits(&mut self, v: u64) {
        self.txnid_least_bits = ::std::option::Option::Some(v);
    }

    // optional uint64 txnid_most_bits = 3;


    pub fn get_txnid_most_bits(&self) -> u64 {
        self.txnid_most_bits.unwrap_or(0u64)
    }
    pub fn clear_txnid_most_bits(&mut self) {
        self.txnid_most_bits = ::std::option::Option::None;
    }

    pub fn has_txnid_most_bits(&self) -> bool {
        self.txnid_most_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnid_most_bits(&mut self, v: u64) {
        self.txnid_most_bits = ::std::option::Option::Some(v);
    }

    // optional .pulsar.proto.ServerError error = 4;


    pub fn get_error(&self) -> ServerError {
        self.error.unwrap_or(ServerError::UnknownError)
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ServerError) {
        self.error = ::std::option::Option::Some(v);
    }

    // optional string message = 5;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CommandEndTxnOnSubscriptionResponse {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_least_bits = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txnid_most_bits = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_least_bits {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txnid_most_bits {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.txnid_least_bits {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.txnid_most_bits {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.error {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandEndTxnOnSubscriptionResponse {
        CommandEndTxnOnSubscriptionResponse::new()
    }

    fn default_instance() -> &'static CommandEndTxnOnSubscriptionResponse {
        static instance: ::protobuf::rt::LazyV2<CommandEndTxnOnSubscriptionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandEndTxnOnSubscriptionResponse::new)
    }
}

impl ::protobuf::Clear for CommandEndTxnOnSubscriptionResponse {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.txnid_least_bits = ::std::option::Option::None;
        self.txnid_most_bits = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandEndTxnOnSubscriptionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct BaseCommand {
    // message fields
    field_type: ::std::option::Option<BaseCommand_Type>,
    pub connect: ::protobuf::SingularPtrField<CommandConnect>,
    pub connected: ::protobuf::SingularPtrField<CommandConnected>,
    pub subscribe: ::protobuf::SingularPtrField<CommandSubscribe>,
    pub producer: ::protobuf::SingularPtrField<CommandProducer>,
    pub send: ::protobuf::SingularPtrField<CommandSend>,
    pub send_receipt: ::protobuf::SingularPtrField<CommandSendReceipt>,
    pub send_error: ::protobuf::SingularPtrField<CommandSendError>,
    pub message: ::protobuf::SingularPtrField<CommandMessage>,
    pub ack: ::protobuf::SingularPtrField<CommandAck>,
    pub flow: ::protobuf::SingularPtrField<CommandFlow>,
    pub unsubscribe: ::protobuf::SingularPtrField<CommandUnsubscribe>,
    pub success: ::protobuf::SingularPtrField<CommandSuccess>,
    pub error: ::protobuf::SingularPtrField<CommandError>,
    pub close_producer: ::protobuf::SingularPtrField<CommandCloseProducer>,
    pub close_consumer: ::protobuf::SingularPtrField<CommandCloseConsumer>,
    pub producer_success: ::protobuf::SingularPtrField<CommandProducerSuccess>,
    pub ping: ::protobuf::SingularPtrField<CommandPing>,
    pub pong: ::protobuf::SingularPtrField<CommandPong>,
    pub redeliverUnacknowledgedMessages: ::protobuf::SingularPtrField<CommandRedeliverUnacknowledgedMessages>,
    pub partitionMetadata: ::protobuf::SingularPtrField<CommandPartitionedTopicMetadata>,
    pub partitionMetadataResponse: ::protobuf::SingularPtrField<CommandPartitionedTopicMetadataResponse>,
    pub lookupTopic: ::protobuf::SingularPtrField<CommandLookupTopic>,
    pub lookupTopicResponse: ::protobuf::SingularPtrField<CommandLookupTopicResponse>,
    pub consumerStats: ::protobuf::SingularPtrField<CommandConsumerStats>,
    pub consumerStatsResponse: ::protobuf::SingularPtrField<CommandConsumerStatsResponse>,
    pub reachedEndOfTopic: ::protobuf::SingularPtrField<CommandReachedEndOfTopic>,
    pub seek: ::protobuf::SingularPtrField<CommandSeek>,
    pub getLastMessageId: ::protobuf::SingularPtrField<CommandGetLastMessageId>,
    pub getLastMessageIdResponse: ::protobuf::SingularPtrField<CommandGetLastMessageIdResponse>,
    pub active_consumer_change: ::protobuf::SingularPtrField<CommandActiveConsumerChange>,
    pub getTopicsOfNamespace: ::protobuf::SingularPtrField<CommandGetTopicsOfNamespace>,
    pub getTopicsOfNamespaceResponse: ::protobuf::SingularPtrField<CommandGetTopicsOfNamespaceResponse>,
    pub getSchema: ::protobuf::SingularPtrField<CommandGetSchema>,
    pub getSchemaResponse: ::protobuf::SingularPtrField<CommandGetSchemaResponse>,
    pub authChallenge: ::protobuf::SingularPtrField<CommandAuthChallenge>,
    pub authResponse: ::protobuf::SingularPtrField<CommandAuthResponse>,
    pub ackResponse: ::protobuf::SingularPtrField<CommandAckResponse>,
    pub getOrCreateSchema: ::protobuf::SingularPtrField<CommandGetOrCreateSchema>,
    pub getOrCreateSchemaResponse: ::protobuf::SingularPtrField<CommandGetOrCreateSchemaResponse>,
    pub newTxn: ::protobuf::SingularPtrField<CommandNewTxn>,
    pub newTxnResponse: ::protobuf::SingularPtrField<CommandNewTxnResponse>,
    pub addPartitionToTxn: ::protobuf::SingularPtrField<CommandAddPartitionToTxn>,
    pub addPartitionToTxnResponse: ::protobuf::SingularPtrField<CommandAddPartitionToTxnResponse>,
    pub addSubscriptionToTxn: ::protobuf::SingularPtrField<CommandAddSubscriptionToTxn>,
    pub addSubscriptionToTxnResponse: ::protobuf::SingularPtrField<CommandAddSubscriptionToTxnResponse>,
    pub endTxn: ::protobuf::SingularPtrField<CommandEndTxn>,
    pub endTxnResponse: ::protobuf::SingularPtrField<CommandEndTxnResponse>,
    pub endTxnOnPartition: ::protobuf::SingularPtrField<CommandEndTxnOnPartition>,
    pub endTxnOnPartitionResponse: ::protobuf::SingularPtrField<CommandEndTxnOnPartitionResponse>,
    pub endTxnOnSubscription: ::protobuf::SingularPtrField<CommandEndTxnOnSubscription>,
    pub endTxnOnSubscriptionResponse: ::protobuf::SingularPtrField<CommandEndTxnOnSubscriptionResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BaseCommand {
    fn default() -> &'a BaseCommand {
        <BaseCommand as ::protobuf::Message>::default_instance()
    }
}

impl BaseCommand {
    pub fn new() -> BaseCommand {
        ::std::default::Default::default()
    }

    // required .pulsar.proto.BaseCommand.Type type = 1;


    pub fn get_field_type(&self) -> BaseCommand_Type {
        self.field_type.unwrap_or(BaseCommand_Type::CONNECT)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: BaseCommand_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional .pulsar.proto.CommandConnect connect = 2;


    pub fn get_connect(&self) -> &CommandConnect {
        self.connect.as_ref().unwrap_or_else(|| <CommandConnect as ::protobuf::Message>::default_instance())
    }
    pub fn clear_connect(&mut self) {
        self.connect.clear();
    }

    pub fn has_connect(&self) -> bool {
        self.connect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect(&mut self, v: CommandConnect) {
        self.connect = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connect(&mut self) -> &mut CommandConnect {
        if self.connect.is_none() {
            self.connect.set_default();
        }
        self.connect.as_mut().unwrap()
    }

    // Take field
    pub fn take_connect(&mut self) -> CommandConnect {
        self.connect.take().unwrap_or_else(|| CommandConnect::new())
    }

    // optional .pulsar.proto.CommandConnected connected = 3;


    pub fn get_connected(&self) -> &CommandConnected {
        self.connected.as_ref().unwrap_or_else(|| <CommandConnected as ::protobuf::Message>::default_instance())
    }
    pub fn clear_connected(&mut self) {
        self.connected.clear();
    }

    pub fn has_connected(&self) -> bool {
        self.connected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connected(&mut self, v: CommandConnected) {
        self.connected = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connected(&mut self) -> &mut CommandConnected {
        if self.connected.is_none() {
            self.connected.set_default();
        }
        self.connected.as_mut().unwrap()
    }

    // Take field
    pub fn take_connected(&mut self) -> CommandConnected {
        self.connected.take().unwrap_or_else(|| CommandConnected::new())
    }

    // optional .pulsar.proto.CommandSubscribe subscribe = 4;


    pub fn get_subscribe(&self) -> &CommandSubscribe {
        self.subscribe.as_ref().unwrap_or_else(|| <CommandSubscribe as ::protobuf::Message>::default_instance())
    }
    pub fn clear_subscribe(&mut self) {
        self.subscribe.clear();
    }

    pub fn has_subscribe(&self) -> bool {
        self.subscribe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscribe(&mut self, v: CommandSubscribe) {
        self.subscribe = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscribe(&mut self) -> &mut CommandSubscribe {
        if self.subscribe.is_none() {
            self.subscribe.set_default();
        }
        self.subscribe.as_mut().unwrap()
    }

    // Take field
    pub fn take_subscribe(&mut self) -> CommandSubscribe {
        self.subscribe.take().unwrap_or_else(|| CommandSubscribe::new())
    }

    // optional .pulsar.proto.CommandProducer producer = 5;


    pub fn get_producer(&self) -> &CommandProducer {
        self.producer.as_ref().unwrap_or_else(|| <CommandProducer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_producer(&mut self) {
        self.producer.clear();
    }

    pub fn has_producer(&self) -> bool {
        self.producer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer(&mut self, v: CommandProducer) {
        self.producer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_producer(&mut self) -> &mut CommandProducer {
        if self.producer.is_none() {
            self.producer.set_default();
        }
        self.producer.as_mut().unwrap()
    }

    // Take field
    pub fn take_producer(&mut self) -> CommandProducer {
        self.producer.take().unwrap_or_else(|| CommandProducer::new())
    }

    // optional .pulsar.proto.CommandSend send = 6;


    pub fn get_send(&self) -> &CommandSend {
        self.send.as_ref().unwrap_or_else(|| <CommandSend as ::protobuf::Message>::default_instance())
    }
    pub fn clear_send(&mut self) {
        self.send.clear();
    }

    pub fn has_send(&self) -> bool {
        self.send.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send(&mut self, v: CommandSend) {
        self.send = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_send(&mut self) -> &mut CommandSend {
        if self.send.is_none() {
            self.send.set_default();
        }
        self.send.as_mut().unwrap()
    }

    // Take field
    pub fn take_send(&mut self) -> CommandSend {
        self.send.take().unwrap_or_else(|| CommandSend::new())
    }

    // optional .pulsar.proto.CommandSendReceipt send_receipt = 7;


    pub fn get_send_receipt(&self) -> &CommandSendReceipt {
        self.send_receipt.as_ref().unwrap_or_else(|| <CommandSendReceipt as ::protobuf::Message>::default_instance())
    }
    pub fn clear_send_receipt(&mut self) {
        self.send_receipt.clear();
    }

    pub fn has_send_receipt(&self) -> bool {
        self.send_receipt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_receipt(&mut self, v: CommandSendReceipt) {
        self.send_receipt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_send_receipt(&mut self) -> &mut CommandSendReceipt {
        if self.send_receipt.is_none() {
            self.send_receipt.set_default();
        }
        self.send_receipt.as_mut().unwrap()
    }

    // Take field
    pub fn take_send_receipt(&mut self) -> CommandSendReceipt {
        self.send_receipt.take().unwrap_or_else(|| CommandSendReceipt::new())
    }

    // optional .pulsar.proto.CommandSendError send_error = 8;


    pub fn get_send_error(&self) -> &CommandSendError {
        self.send_error.as_ref().unwrap_or_else(|| <CommandSendError as ::protobuf::Message>::default_instance())
    }
    pub fn clear_send_error(&mut self) {
        self.send_error.clear();
    }

    pub fn has_send_error(&self) -> bool {
        self.send_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_error(&mut self, v: CommandSendError) {
        self.send_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_send_error(&mut self) -> &mut CommandSendError {
        if self.send_error.is_none() {
            self.send_error.set_default();
        }
        self.send_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_send_error(&mut self) -> CommandSendError {
        self.send_error.take().unwrap_or_else(|| CommandSendError::new())
    }

    // optional .pulsar.proto.CommandMessage message = 9;


    pub fn get_message(&self) -> &CommandMessage {
        self.message.as_ref().unwrap_or_else(|| <CommandMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: CommandMessage) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut CommandMessage {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> CommandMessage {
        self.message.take().unwrap_or_else(|| CommandMessage::new())
    }

    // optional .pulsar.proto.CommandAck ack = 10;


    pub fn get_ack(&self) -> &CommandAck {
        self.ack.as_ref().unwrap_or_else(|| <CommandAck as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ack(&mut self) {
        self.ack.clear();
    }

    pub fn has_ack(&self) -> bool {
        self.ack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack(&mut self, v: CommandAck) {
        self.ack = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ack(&mut self) -> &mut CommandAck {
        if self.ack.is_none() {
            self.ack.set_default();
        }
        self.ack.as_mut().unwrap()
    }

    // Take field
    pub fn take_ack(&mut self) -> CommandAck {
        self.ack.take().unwrap_or_else(|| CommandAck::new())
    }

    // optional .pulsar.proto.CommandFlow flow = 11;


    pub fn get_flow(&self) -> &CommandFlow {
        self.flow.as_ref().unwrap_or_else(|| <CommandFlow as ::protobuf::Message>::default_instance())
    }
    pub fn clear_flow(&mut self) {
        self.flow.clear();
    }

    pub fn has_flow(&self) -> bool {
        self.flow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flow(&mut self, v: CommandFlow) {
        self.flow = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flow(&mut self) -> &mut CommandFlow {
        if self.flow.is_none() {
            self.flow.set_default();
        }
        self.flow.as_mut().unwrap()
    }

    // Take field
    pub fn take_flow(&mut self) -> CommandFlow {
        self.flow.take().unwrap_or_else(|| CommandFlow::new())
    }

    // optional .pulsar.proto.CommandUnsubscribe unsubscribe = 12;


    pub fn get_unsubscribe(&self) -> &CommandUnsubscribe {
        self.unsubscribe.as_ref().unwrap_or_else(|| <CommandUnsubscribe as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unsubscribe(&mut self) {
        self.unsubscribe.clear();
    }

    pub fn has_unsubscribe(&self) -> bool {
        self.unsubscribe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unsubscribe(&mut self, v: CommandUnsubscribe) {
        self.unsubscribe = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unsubscribe(&mut self) -> &mut CommandUnsubscribe {
        if self.unsubscribe.is_none() {
            self.unsubscribe.set_default();
        }
        self.unsubscribe.as_mut().unwrap()
    }

    // Take field
    pub fn take_unsubscribe(&mut self) -> CommandUnsubscribe {
        self.unsubscribe.take().unwrap_or_else(|| CommandUnsubscribe::new())
    }

    // optional .pulsar.proto.CommandSuccess success = 13;


    pub fn get_success(&self) -> &CommandSuccess {
        self.success.as_ref().unwrap_or_else(|| <CommandSuccess as ::protobuf::Message>::default_instance())
    }
    pub fn clear_success(&mut self) {
        self.success.clear();
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: CommandSuccess) {
        self.success = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_success(&mut self) -> &mut CommandSuccess {
        if self.success.is_none() {
            self.success.set_default();
        }
        self.success.as_mut().unwrap()
    }

    // Take field
    pub fn take_success(&mut self) -> CommandSuccess {
        self.success.take().unwrap_or_else(|| CommandSuccess::new())
    }

    // optional .pulsar.proto.CommandError error = 14;


    pub fn get_error(&self) -> &CommandError {
        self.error.as_ref().unwrap_or_else(|| <CommandError as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CommandError) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut CommandError {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> CommandError {
        self.error.take().unwrap_or_else(|| CommandError::new())
    }

    // optional .pulsar.proto.CommandCloseProducer close_producer = 15;


    pub fn get_close_producer(&self) -> &CommandCloseProducer {
        self.close_producer.as_ref().unwrap_or_else(|| <CommandCloseProducer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_close_producer(&mut self) {
        self.close_producer.clear();
    }

    pub fn has_close_producer(&self) -> bool {
        self.close_producer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close_producer(&mut self, v: CommandCloseProducer) {
        self.close_producer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_close_producer(&mut self) -> &mut CommandCloseProducer {
        if self.close_producer.is_none() {
            self.close_producer.set_default();
        }
        self.close_producer.as_mut().unwrap()
    }

    // Take field
    pub fn take_close_producer(&mut self) -> CommandCloseProducer {
        self.close_producer.take().unwrap_or_else(|| CommandCloseProducer::new())
    }

    // optional .pulsar.proto.CommandCloseConsumer close_consumer = 16;


    pub fn get_close_consumer(&self) -> &CommandCloseConsumer {
        self.close_consumer.as_ref().unwrap_or_else(|| <CommandCloseConsumer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_close_consumer(&mut self) {
        self.close_consumer.clear();
    }

    pub fn has_close_consumer(&self) -> bool {
        self.close_consumer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close_consumer(&mut self, v: CommandCloseConsumer) {
        self.close_consumer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_close_consumer(&mut self) -> &mut CommandCloseConsumer {
        if self.close_consumer.is_none() {
            self.close_consumer.set_default();
        }
        self.close_consumer.as_mut().unwrap()
    }

    // Take field
    pub fn take_close_consumer(&mut self) -> CommandCloseConsumer {
        self.close_consumer.take().unwrap_or_else(|| CommandCloseConsumer::new())
    }

    // optional .pulsar.proto.CommandProducerSuccess producer_success = 17;


    pub fn get_producer_success(&self) -> &CommandProducerSuccess {
        self.producer_success.as_ref().unwrap_or_else(|| <CommandProducerSuccess as ::protobuf::Message>::default_instance())
    }
    pub fn clear_producer_success(&mut self) {
        self.producer_success.clear();
    }

    pub fn has_producer_success(&self) -> bool {
        self.producer_success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_success(&mut self, v: CommandProducerSuccess) {
        self.producer_success = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_producer_success(&mut self) -> &mut CommandProducerSuccess {
        if self.producer_success.is_none() {
            self.producer_success.set_default();
        }
        self.producer_success.as_mut().unwrap()
    }

    // Take field
    pub fn take_producer_success(&mut self) -> CommandProducerSuccess {
        self.producer_success.take().unwrap_or_else(|| CommandProducerSuccess::new())
    }

    // optional .pulsar.proto.CommandPing ping = 18;


    pub fn get_ping(&self) -> &CommandPing {
        self.ping.as_ref().unwrap_or_else(|| <CommandPing as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ping(&mut self) {
        self.ping.clear();
    }

    pub fn has_ping(&self) -> bool {
        self.ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: CommandPing) {
        self.ping = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ping(&mut self) -> &mut CommandPing {
        if self.ping.is_none() {
            self.ping.set_default();
        }
        self.ping.as_mut().unwrap()
    }

    // Take field
    pub fn take_ping(&mut self) -> CommandPing {
        self.ping.take().unwrap_or_else(|| CommandPing::new())
    }

    // optional .pulsar.proto.CommandPong pong = 19;


    pub fn get_pong(&self) -> &CommandPong {
        self.pong.as_ref().unwrap_or_else(|| <CommandPong as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pong(&mut self) {
        self.pong.clear();
    }

    pub fn has_pong(&self) -> bool {
        self.pong.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pong(&mut self, v: CommandPong) {
        self.pong = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pong(&mut self) -> &mut CommandPong {
        if self.pong.is_none() {
            self.pong.set_default();
        }
        self.pong.as_mut().unwrap()
    }

    // Take field
    pub fn take_pong(&mut self) -> CommandPong {
        self.pong.take().unwrap_or_else(|| CommandPong::new())
    }

    // optional .pulsar.proto.CommandRedeliverUnacknowledgedMessages redeliverUnacknowledgedMessages = 20;


    pub fn get_redeliverUnacknowledgedMessages(&self) -> &CommandRedeliverUnacknowledgedMessages {
        self.redeliverUnacknowledgedMessages.as_ref().unwrap_or_else(|| <CommandRedeliverUnacknowledgedMessages as ::protobuf::Message>::default_instance())
    }
    pub fn clear_redeliverUnacknowledgedMessages(&mut self) {
        self.redeliverUnacknowledgedMessages.clear();
    }

    pub fn has_redeliverUnacknowledgedMessages(&self) -> bool {
        self.redeliverUnacknowledgedMessages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_redeliverUnacknowledgedMessages(&mut self, v: CommandRedeliverUnacknowledgedMessages) {
        self.redeliverUnacknowledgedMessages = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_redeliverUnacknowledgedMessages(&mut self) -> &mut CommandRedeliverUnacknowledgedMessages {
        if self.redeliverUnacknowledgedMessages.is_none() {
            self.redeliverUnacknowledgedMessages.set_default();
        }
        self.redeliverUnacknowledgedMessages.as_mut().unwrap()
    }

    // Take field
    pub fn take_redeliverUnacknowledgedMessages(&mut self) -> CommandRedeliverUnacknowledgedMessages {
        self.redeliverUnacknowledgedMessages.take().unwrap_or_else(|| CommandRedeliverUnacknowledgedMessages::new())
    }

    // optional .pulsar.proto.CommandPartitionedTopicMetadata partitionMetadata = 21;


    pub fn get_partitionMetadata(&self) -> &CommandPartitionedTopicMetadata {
        self.partitionMetadata.as_ref().unwrap_or_else(|| <CommandPartitionedTopicMetadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_partitionMetadata(&mut self) {
        self.partitionMetadata.clear();
    }

    pub fn has_partitionMetadata(&self) -> bool {
        self.partitionMetadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partitionMetadata(&mut self, v: CommandPartitionedTopicMetadata) {
        self.partitionMetadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_partitionMetadata(&mut self) -> &mut CommandPartitionedTopicMetadata {
        if self.partitionMetadata.is_none() {
            self.partitionMetadata.set_default();
        }
        self.partitionMetadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_partitionMetadata(&mut self) -> CommandPartitionedTopicMetadata {
        self.partitionMetadata.take().unwrap_or_else(|| CommandPartitionedTopicMetadata::new())
    }

    // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse partitionMetadataResponse = 22;


    pub fn get_partitionMetadataResponse(&self) -> &CommandPartitionedTopicMetadataResponse {
        self.partitionMetadataResponse.as_ref().unwrap_or_else(|| <CommandPartitionedTopicMetadataResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_partitionMetadataResponse(&mut self) {
        self.partitionMetadataResponse.clear();
    }

    pub fn has_partitionMetadataResponse(&self) -> bool {
        self.partitionMetadataResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partitionMetadataResponse(&mut self, v: CommandPartitionedTopicMetadataResponse) {
        self.partitionMetadataResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_partitionMetadataResponse(&mut self) -> &mut CommandPartitionedTopicMetadataResponse {
        if self.partitionMetadataResponse.is_none() {
            self.partitionMetadataResponse.set_default();
        }
        self.partitionMetadataResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_partitionMetadataResponse(&mut self) -> CommandPartitionedTopicMetadataResponse {
        self.partitionMetadataResponse.take().unwrap_or_else(|| CommandPartitionedTopicMetadataResponse::new())
    }

    // optional .pulsar.proto.CommandLookupTopic lookupTopic = 23;


    pub fn get_lookupTopic(&self) -> &CommandLookupTopic {
        self.lookupTopic.as_ref().unwrap_or_else(|| <CommandLookupTopic as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lookupTopic(&mut self) {
        self.lookupTopic.clear();
    }

    pub fn has_lookupTopic(&self) -> bool {
        self.lookupTopic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lookupTopic(&mut self, v: CommandLookupTopic) {
        self.lookupTopic = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lookupTopic(&mut self) -> &mut CommandLookupTopic {
        if self.lookupTopic.is_none() {
            self.lookupTopic.set_default();
        }
        self.lookupTopic.as_mut().unwrap()
    }

    // Take field
    pub fn take_lookupTopic(&mut self) -> CommandLookupTopic {
        self.lookupTopic.take().unwrap_or_else(|| CommandLookupTopic::new())
    }

    // optional .pulsar.proto.CommandLookupTopicResponse lookupTopicResponse = 24;


    pub fn get_lookupTopicResponse(&self) -> &CommandLookupTopicResponse {
        self.lookupTopicResponse.as_ref().unwrap_or_else(|| <CommandLookupTopicResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lookupTopicResponse(&mut self) {
        self.lookupTopicResponse.clear();
    }

    pub fn has_lookupTopicResponse(&self) -> bool {
        self.lookupTopicResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lookupTopicResponse(&mut self, v: CommandLookupTopicResponse) {
        self.lookupTopicResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lookupTopicResponse(&mut self) -> &mut CommandLookupTopicResponse {
        if self.lookupTopicResponse.is_none() {
            self.lookupTopicResponse.set_default();
        }
        self.lookupTopicResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_lookupTopicResponse(&mut self) -> CommandLookupTopicResponse {
        self.lookupTopicResponse.take().unwrap_or_else(|| CommandLookupTopicResponse::new())
    }

    // optional .pulsar.proto.CommandConsumerStats consumerStats = 25;


    pub fn get_consumerStats(&self) -> &CommandConsumerStats {
        self.consumerStats.as_ref().unwrap_or_else(|| <CommandConsumerStats as ::protobuf::Message>::default_instance())
    }
    pub fn clear_consumerStats(&mut self) {
        self.consumerStats.clear();
    }

    pub fn has_consumerStats(&self) -> bool {
        self.consumerStats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumerStats(&mut self, v: CommandConsumerStats) {
        self.consumerStats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumerStats(&mut self) -> &mut CommandConsumerStats {
        if self.consumerStats.is_none() {
            self.consumerStats.set_default();
        }
        self.consumerStats.as_mut().unwrap()
    }

    // Take field
    pub fn take_consumerStats(&mut self) -> CommandConsumerStats {
        self.consumerStats.take().unwrap_or_else(|| CommandConsumerStats::new())
    }

    // optional .pulsar.proto.CommandConsumerStatsResponse consumerStatsResponse = 26;


    pub fn get_consumerStatsResponse(&self) -> &CommandConsumerStatsResponse {
        self.consumerStatsResponse.as_ref().unwrap_or_else(|| <CommandConsumerStatsResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_consumerStatsResponse(&mut self) {
        self.consumerStatsResponse.clear();
    }

    pub fn has_consumerStatsResponse(&self) -> bool {
        self.consumerStatsResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumerStatsResponse(&mut self, v: CommandConsumerStatsResponse) {
        self.consumerStatsResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumerStatsResponse(&mut self) -> &mut CommandConsumerStatsResponse {
        if self.consumerStatsResponse.is_none() {
            self.consumerStatsResponse.set_default();
        }
        self.consumerStatsResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_consumerStatsResponse(&mut self) -> CommandConsumerStatsResponse {
        self.consumerStatsResponse.take().unwrap_or_else(|| CommandConsumerStatsResponse::new())
    }

    // optional .pulsar.proto.CommandReachedEndOfTopic reachedEndOfTopic = 27;


    pub fn get_reachedEndOfTopic(&self) -> &CommandReachedEndOfTopic {
        self.reachedEndOfTopic.as_ref().unwrap_or_else(|| <CommandReachedEndOfTopic as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reachedEndOfTopic(&mut self) {
        self.reachedEndOfTopic.clear();
    }

    pub fn has_reachedEndOfTopic(&self) -> bool {
        self.reachedEndOfTopic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reachedEndOfTopic(&mut self, v: CommandReachedEndOfTopic) {
        self.reachedEndOfTopic = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reachedEndOfTopic(&mut self) -> &mut CommandReachedEndOfTopic {
        if self.reachedEndOfTopic.is_none() {
            self.reachedEndOfTopic.set_default();
        }
        self.reachedEndOfTopic.as_mut().unwrap()
    }

    // Take field
    pub fn take_reachedEndOfTopic(&mut self) -> CommandReachedEndOfTopic {
        self.reachedEndOfTopic.take().unwrap_or_else(|| CommandReachedEndOfTopic::new())
    }

    // optional .pulsar.proto.CommandSeek seek = 28;


    pub fn get_seek(&self) -> &CommandSeek {
        self.seek.as_ref().unwrap_or_else(|| <CommandSeek as ::protobuf::Message>::default_instance())
    }
    pub fn clear_seek(&mut self) {
        self.seek.clear();
    }

    pub fn has_seek(&self) -> bool {
        self.seek.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seek(&mut self, v: CommandSeek) {
        self.seek = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seek(&mut self) -> &mut CommandSeek {
        if self.seek.is_none() {
            self.seek.set_default();
        }
        self.seek.as_mut().unwrap()
    }

    // Take field
    pub fn take_seek(&mut self) -> CommandSeek {
        self.seek.take().unwrap_or_else(|| CommandSeek::new())
    }

    // optional .pulsar.proto.CommandGetLastMessageId getLastMessageId = 29;


    pub fn get_getLastMessageId(&self) -> &CommandGetLastMessageId {
        self.getLastMessageId.as_ref().unwrap_or_else(|| <CommandGetLastMessageId as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getLastMessageId(&mut self) {
        self.getLastMessageId.clear();
    }

    pub fn has_getLastMessageId(&self) -> bool {
        self.getLastMessageId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getLastMessageId(&mut self, v: CommandGetLastMessageId) {
        self.getLastMessageId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getLastMessageId(&mut self) -> &mut CommandGetLastMessageId {
        if self.getLastMessageId.is_none() {
            self.getLastMessageId.set_default();
        }
        self.getLastMessageId.as_mut().unwrap()
    }

    // Take field
    pub fn take_getLastMessageId(&mut self) -> CommandGetLastMessageId {
        self.getLastMessageId.take().unwrap_or_else(|| CommandGetLastMessageId::new())
    }

    // optional .pulsar.proto.CommandGetLastMessageIdResponse getLastMessageIdResponse = 30;


    pub fn get_getLastMessageIdResponse(&self) -> &CommandGetLastMessageIdResponse {
        self.getLastMessageIdResponse.as_ref().unwrap_or_else(|| <CommandGetLastMessageIdResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getLastMessageIdResponse(&mut self) {
        self.getLastMessageIdResponse.clear();
    }

    pub fn has_getLastMessageIdResponse(&self) -> bool {
        self.getLastMessageIdResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getLastMessageIdResponse(&mut self, v: CommandGetLastMessageIdResponse) {
        self.getLastMessageIdResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getLastMessageIdResponse(&mut self) -> &mut CommandGetLastMessageIdResponse {
        if self.getLastMessageIdResponse.is_none() {
            self.getLastMessageIdResponse.set_default();
        }
        self.getLastMessageIdResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_getLastMessageIdResponse(&mut self) -> CommandGetLastMessageIdResponse {
        self.getLastMessageIdResponse.take().unwrap_or_else(|| CommandGetLastMessageIdResponse::new())
    }

    // optional .pulsar.proto.CommandActiveConsumerChange active_consumer_change = 31;


    pub fn get_active_consumer_change(&self) -> &CommandActiveConsumerChange {
        self.active_consumer_change.as_ref().unwrap_or_else(|| <CommandActiveConsumerChange as ::protobuf::Message>::default_instance())
    }
    pub fn clear_active_consumer_change(&mut self) {
        self.active_consumer_change.clear();
    }

    pub fn has_active_consumer_change(&self) -> bool {
        self.active_consumer_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_consumer_change(&mut self, v: CommandActiveConsumerChange) {
        self.active_consumer_change = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_active_consumer_change(&mut self) -> &mut CommandActiveConsumerChange {
        if self.active_consumer_change.is_none() {
            self.active_consumer_change.set_default();
        }
        self.active_consumer_change.as_mut().unwrap()
    }

    // Take field
    pub fn take_active_consumer_change(&mut self) -> CommandActiveConsumerChange {
        self.active_consumer_change.take().unwrap_or_else(|| CommandActiveConsumerChange::new())
    }

    // optional .pulsar.proto.CommandGetTopicsOfNamespace getTopicsOfNamespace = 32;


    pub fn get_getTopicsOfNamespace(&self) -> &CommandGetTopicsOfNamespace {
        self.getTopicsOfNamespace.as_ref().unwrap_or_else(|| <CommandGetTopicsOfNamespace as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getTopicsOfNamespace(&mut self) {
        self.getTopicsOfNamespace.clear();
    }

    pub fn has_getTopicsOfNamespace(&self) -> bool {
        self.getTopicsOfNamespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getTopicsOfNamespace(&mut self, v: CommandGetTopicsOfNamespace) {
        self.getTopicsOfNamespace = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getTopicsOfNamespace(&mut self) -> &mut CommandGetTopicsOfNamespace {
        if self.getTopicsOfNamespace.is_none() {
            self.getTopicsOfNamespace.set_default();
        }
        self.getTopicsOfNamespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_getTopicsOfNamespace(&mut self) -> CommandGetTopicsOfNamespace {
        self.getTopicsOfNamespace.take().unwrap_or_else(|| CommandGetTopicsOfNamespace::new())
    }

    // optional .pulsar.proto.CommandGetTopicsOfNamespaceResponse getTopicsOfNamespaceResponse = 33;


    pub fn get_getTopicsOfNamespaceResponse(&self) -> &CommandGetTopicsOfNamespaceResponse {
        self.getTopicsOfNamespaceResponse.as_ref().unwrap_or_else(|| <CommandGetTopicsOfNamespaceResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getTopicsOfNamespaceResponse(&mut self) {
        self.getTopicsOfNamespaceResponse.clear();
    }

    pub fn has_getTopicsOfNamespaceResponse(&self) -> bool {
        self.getTopicsOfNamespaceResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getTopicsOfNamespaceResponse(&mut self, v: CommandGetTopicsOfNamespaceResponse) {
        self.getTopicsOfNamespaceResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getTopicsOfNamespaceResponse(&mut self) -> &mut CommandGetTopicsOfNamespaceResponse {
        if self.getTopicsOfNamespaceResponse.is_none() {
            self.getTopicsOfNamespaceResponse.set_default();
        }
        self.getTopicsOfNamespaceResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_getTopicsOfNamespaceResponse(&mut self) -> CommandGetTopicsOfNamespaceResponse {
        self.getTopicsOfNamespaceResponse.take().unwrap_or_else(|| CommandGetTopicsOfNamespaceResponse::new())
    }

    // optional .pulsar.proto.CommandGetSchema getSchema = 34;


    pub fn get_getSchema(&self) -> &CommandGetSchema {
        self.getSchema.as_ref().unwrap_or_else(|| <CommandGetSchema as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getSchema(&mut self) {
        self.getSchema.clear();
    }

    pub fn has_getSchema(&self) -> bool {
        self.getSchema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getSchema(&mut self, v: CommandGetSchema) {
        self.getSchema = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getSchema(&mut self) -> &mut CommandGetSchema {
        if self.getSchema.is_none() {
            self.getSchema.set_default();
        }
        self.getSchema.as_mut().unwrap()
    }

    // Take field
    pub fn take_getSchema(&mut self) -> CommandGetSchema {
        self.getSchema.take().unwrap_or_else(|| CommandGetSchema::new())
    }

    // optional .pulsar.proto.CommandGetSchemaResponse getSchemaResponse = 35;


    pub fn get_getSchemaResponse(&self) -> &CommandGetSchemaResponse {
        self.getSchemaResponse.as_ref().unwrap_or_else(|| <CommandGetSchemaResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getSchemaResponse(&mut self) {
        self.getSchemaResponse.clear();
    }

    pub fn has_getSchemaResponse(&self) -> bool {
        self.getSchemaResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getSchemaResponse(&mut self, v: CommandGetSchemaResponse) {
        self.getSchemaResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getSchemaResponse(&mut self) -> &mut CommandGetSchemaResponse {
        if self.getSchemaResponse.is_none() {
            self.getSchemaResponse.set_default();
        }
        self.getSchemaResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_getSchemaResponse(&mut self) -> CommandGetSchemaResponse {
        self.getSchemaResponse.take().unwrap_or_else(|| CommandGetSchemaResponse::new())
    }

    // optional .pulsar.proto.CommandAuthChallenge authChallenge = 36;


    pub fn get_authChallenge(&self) -> &CommandAuthChallenge {
        self.authChallenge.as_ref().unwrap_or_else(|| <CommandAuthChallenge as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authChallenge(&mut self) {
        self.authChallenge.clear();
    }

    pub fn has_authChallenge(&self) -> bool {
        self.authChallenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authChallenge(&mut self, v: CommandAuthChallenge) {
        self.authChallenge = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authChallenge(&mut self) -> &mut CommandAuthChallenge {
        if self.authChallenge.is_none() {
            self.authChallenge.set_default();
        }
        self.authChallenge.as_mut().unwrap()
    }

    // Take field
    pub fn take_authChallenge(&mut self) -> CommandAuthChallenge {
        self.authChallenge.take().unwrap_or_else(|| CommandAuthChallenge::new())
    }

    // optional .pulsar.proto.CommandAuthResponse authResponse = 37;


    pub fn get_authResponse(&self) -> &CommandAuthResponse {
        self.authResponse.as_ref().unwrap_or_else(|| <CommandAuthResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authResponse(&mut self) {
        self.authResponse.clear();
    }

    pub fn has_authResponse(&self) -> bool {
        self.authResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authResponse(&mut self, v: CommandAuthResponse) {
        self.authResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authResponse(&mut self) -> &mut CommandAuthResponse {
        if self.authResponse.is_none() {
            self.authResponse.set_default();
        }
        self.authResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_authResponse(&mut self) -> CommandAuthResponse {
        self.authResponse.take().unwrap_or_else(|| CommandAuthResponse::new())
    }

    // optional .pulsar.proto.CommandAckResponse ackResponse = 38;


    pub fn get_ackResponse(&self) -> &CommandAckResponse {
        self.ackResponse.as_ref().unwrap_or_else(|| <CommandAckResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ackResponse(&mut self) {
        self.ackResponse.clear();
    }

    pub fn has_ackResponse(&self) -> bool {
        self.ackResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ackResponse(&mut self, v: CommandAckResponse) {
        self.ackResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ackResponse(&mut self) -> &mut CommandAckResponse {
        if self.ackResponse.is_none() {
            self.ackResponse.set_default();
        }
        self.ackResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_ackResponse(&mut self) -> CommandAckResponse {
        self.ackResponse.take().unwrap_or_else(|| CommandAckResponse::new())
    }

    // optional .pulsar.proto.CommandGetOrCreateSchema getOrCreateSchema = 39;


    pub fn get_getOrCreateSchema(&self) -> &CommandGetOrCreateSchema {
        self.getOrCreateSchema.as_ref().unwrap_or_else(|| <CommandGetOrCreateSchema as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getOrCreateSchema(&mut self) {
        self.getOrCreateSchema.clear();
    }

    pub fn has_getOrCreateSchema(&self) -> bool {
        self.getOrCreateSchema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getOrCreateSchema(&mut self, v: CommandGetOrCreateSchema) {
        self.getOrCreateSchema = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getOrCreateSchema(&mut self) -> &mut CommandGetOrCreateSchema {
        if self.getOrCreateSchema.is_none() {
            self.getOrCreateSchema.set_default();
        }
        self.getOrCreateSchema.as_mut().unwrap()
    }

    // Take field
    pub fn take_getOrCreateSchema(&mut self) -> CommandGetOrCreateSchema {
        self.getOrCreateSchema.take().unwrap_or_else(|| CommandGetOrCreateSchema::new())
    }

    // optional .pulsar.proto.CommandGetOrCreateSchemaResponse getOrCreateSchemaResponse = 40;


    pub fn get_getOrCreateSchemaResponse(&self) -> &CommandGetOrCreateSchemaResponse {
        self.getOrCreateSchemaResponse.as_ref().unwrap_or_else(|| <CommandGetOrCreateSchemaResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getOrCreateSchemaResponse(&mut self) {
        self.getOrCreateSchemaResponse.clear();
    }

    pub fn has_getOrCreateSchemaResponse(&self) -> bool {
        self.getOrCreateSchemaResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getOrCreateSchemaResponse(&mut self, v: CommandGetOrCreateSchemaResponse) {
        self.getOrCreateSchemaResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getOrCreateSchemaResponse(&mut self) -> &mut CommandGetOrCreateSchemaResponse {
        if self.getOrCreateSchemaResponse.is_none() {
            self.getOrCreateSchemaResponse.set_default();
        }
        self.getOrCreateSchemaResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_getOrCreateSchemaResponse(&mut self) -> CommandGetOrCreateSchemaResponse {
        self.getOrCreateSchemaResponse.take().unwrap_or_else(|| CommandGetOrCreateSchemaResponse::new())
    }

    // optional .pulsar.proto.CommandNewTxn newTxn = 50;


    pub fn get_newTxn(&self) -> &CommandNewTxn {
        self.newTxn.as_ref().unwrap_or_else(|| <CommandNewTxn as ::protobuf::Message>::default_instance())
    }
    pub fn clear_newTxn(&mut self) {
        self.newTxn.clear();
    }

    pub fn has_newTxn(&self) -> bool {
        self.newTxn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newTxn(&mut self, v: CommandNewTxn) {
        self.newTxn = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_newTxn(&mut self) -> &mut CommandNewTxn {
        if self.newTxn.is_none() {
            self.newTxn.set_default();
        }
        self.newTxn.as_mut().unwrap()
    }

    // Take field
    pub fn take_newTxn(&mut self) -> CommandNewTxn {
        self.newTxn.take().unwrap_or_else(|| CommandNewTxn::new())
    }

    // optional .pulsar.proto.CommandNewTxnResponse newTxnResponse = 51;


    pub fn get_newTxnResponse(&self) -> &CommandNewTxnResponse {
        self.newTxnResponse.as_ref().unwrap_or_else(|| <CommandNewTxnResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_newTxnResponse(&mut self) {
        self.newTxnResponse.clear();
    }

    pub fn has_newTxnResponse(&self) -> bool {
        self.newTxnResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newTxnResponse(&mut self, v: CommandNewTxnResponse) {
        self.newTxnResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_newTxnResponse(&mut self) -> &mut CommandNewTxnResponse {
        if self.newTxnResponse.is_none() {
            self.newTxnResponse.set_default();
        }
        self.newTxnResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_newTxnResponse(&mut self) -> CommandNewTxnResponse {
        self.newTxnResponse.take().unwrap_or_else(|| CommandNewTxnResponse::new())
    }

    // optional .pulsar.proto.CommandAddPartitionToTxn addPartitionToTxn = 52;


    pub fn get_addPartitionToTxn(&self) -> &CommandAddPartitionToTxn {
        self.addPartitionToTxn.as_ref().unwrap_or_else(|| <CommandAddPartitionToTxn as ::protobuf::Message>::default_instance())
    }
    pub fn clear_addPartitionToTxn(&mut self) {
        self.addPartitionToTxn.clear();
    }

    pub fn has_addPartitionToTxn(&self) -> bool {
        self.addPartitionToTxn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addPartitionToTxn(&mut self, v: CommandAddPartitionToTxn) {
        self.addPartitionToTxn = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addPartitionToTxn(&mut self) -> &mut CommandAddPartitionToTxn {
        if self.addPartitionToTxn.is_none() {
            self.addPartitionToTxn.set_default();
        }
        self.addPartitionToTxn.as_mut().unwrap()
    }

    // Take field
    pub fn take_addPartitionToTxn(&mut self) -> CommandAddPartitionToTxn {
        self.addPartitionToTxn.take().unwrap_or_else(|| CommandAddPartitionToTxn::new())
    }

    // optional .pulsar.proto.CommandAddPartitionToTxnResponse addPartitionToTxnResponse = 53;


    pub fn get_addPartitionToTxnResponse(&self) -> &CommandAddPartitionToTxnResponse {
        self.addPartitionToTxnResponse.as_ref().unwrap_or_else(|| <CommandAddPartitionToTxnResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_addPartitionToTxnResponse(&mut self) {
        self.addPartitionToTxnResponse.clear();
    }

    pub fn has_addPartitionToTxnResponse(&self) -> bool {
        self.addPartitionToTxnResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addPartitionToTxnResponse(&mut self, v: CommandAddPartitionToTxnResponse) {
        self.addPartitionToTxnResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addPartitionToTxnResponse(&mut self) -> &mut CommandAddPartitionToTxnResponse {
        if self.addPartitionToTxnResponse.is_none() {
            self.addPartitionToTxnResponse.set_default();
        }
        self.addPartitionToTxnResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_addPartitionToTxnResponse(&mut self) -> CommandAddPartitionToTxnResponse {
        self.addPartitionToTxnResponse.take().unwrap_or_else(|| CommandAddPartitionToTxnResponse::new())
    }

    // optional .pulsar.proto.CommandAddSubscriptionToTxn addSubscriptionToTxn = 54;


    pub fn get_addSubscriptionToTxn(&self) -> &CommandAddSubscriptionToTxn {
        self.addSubscriptionToTxn.as_ref().unwrap_or_else(|| <CommandAddSubscriptionToTxn as ::protobuf::Message>::default_instance())
    }
    pub fn clear_addSubscriptionToTxn(&mut self) {
        self.addSubscriptionToTxn.clear();
    }

    pub fn has_addSubscriptionToTxn(&self) -> bool {
        self.addSubscriptionToTxn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addSubscriptionToTxn(&mut self, v: CommandAddSubscriptionToTxn) {
        self.addSubscriptionToTxn = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addSubscriptionToTxn(&mut self) -> &mut CommandAddSubscriptionToTxn {
        if self.addSubscriptionToTxn.is_none() {
            self.addSubscriptionToTxn.set_default();
        }
        self.addSubscriptionToTxn.as_mut().unwrap()
    }

    // Take field
    pub fn take_addSubscriptionToTxn(&mut self) -> CommandAddSubscriptionToTxn {
        self.addSubscriptionToTxn.take().unwrap_or_else(|| CommandAddSubscriptionToTxn::new())
    }

    // optional .pulsar.proto.CommandAddSubscriptionToTxnResponse addSubscriptionToTxnResponse = 55;


    pub fn get_addSubscriptionToTxnResponse(&self) -> &CommandAddSubscriptionToTxnResponse {
        self.addSubscriptionToTxnResponse.as_ref().unwrap_or_else(|| <CommandAddSubscriptionToTxnResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_addSubscriptionToTxnResponse(&mut self) {
        self.addSubscriptionToTxnResponse.clear();
    }

    pub fn has_addSubscriptionToTxnResponse(&self) -> bool {
        self.addSubscriptionToTxnResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addSubscriptionToTxnResponse(&mut self, v: CommandAddSubscriptionToTxnResponse) {
        self.addSubscriptionToTxnResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addSubscriptionToTxnResponse(&mut self) -> &mut CommandAddSubscriptionToTxnResponse {
        if self.addSubscriptionToTxnResponse.is_none() {
            self.addSubscriptionToTxnResponse.set_default();
        }
        self.addSubscriptionToTxnResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_addSubscriptionToTxnResponse(&mut self) -> CommandAddSubscriptionToTxnResponse {
        self.addSubscriptionToTxnResponse.take().unwrap_or_else(|| CommandAddSubscriptionToTxnResponse::new())
    }

    // optional .pulsar.proto.CommandEndTxn endTxn = 56;


    pub fn get_endTxn(&self) -> &CommandEndTxn {
        self.endTxn.as_ref().unwrap_or_else(|| <CommandEndTxn as ::protobuf::Message>::default_instance())
    }
    pub fn clear_endTxn(&mut self) {
        self.endTxn.clear();
    }

    pub fn has_endTxn(&self) -> bool {
        self.endTxn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endTxn(&mut self, v: CommandEndTxn) {
        self.endTxn = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endTxn(&mut self) -> &mut CommandEndTxn {
        if self.endTxn.is_none() {
            self.endTxn.set_default();
        }
        self.endTxn.as_mut().unwrap()
    }

    // Take field
    pub fn take_endTxn(&mut self) -> CommandEndTxn {
        self.endTxn.take().unwrap_or_else(|| CommandEndTxn::new())
    }

    // optional .pulsar.proto.CommandEndTxnResponse endTxnResponse = 57;


    pub fn get_endTxnResponse(&self) -> &CommandEndTxnResponse {
        self.endTxnResponse.as_ref().unwrap_or_else(|| <CommandEndTxnResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_endTxnResponse(&mut self) {
        self.endTxnResponse.clear();
    }

    pub fn has_endTxnResponse(&self) -> bool {
        self.endTxnResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endTxnResponse(&mut self, v: CommandEndTxnResponse) {
        self.endTxnResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endTxnResponse(&mut self) -> &mut CommandEndTxnResponse {
        if self.endTxnResponse.is_none() {
            self.endTxnResponse.set_default();
        }
        self.endTxnResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_endTxnResponse(&mut self) -> CommandEndTxnResponse {
        self.endTxnResponse.take().unwrap_or_else(|| CommandEndTxnResponse::new())
    }

    // optional .pulsar.proto.CommandEndTxnOnPartition endTxnOnPartition = 58;


    pub fn get_endTxnOnPartition(&self) -> &CommandEndTxnOnPartition {
        self.endTxnOnPartition.as_ref().unwrap_or_else(|| <CommandEndTxnOnPartition as ::protobuf::Message>::default_instance())
    }
    pub fn clear_endTxnOnPartition(&mut self) {
        self.endTxnOnPartition.clear();
    }

    pub fn has_endTxnOnPartition(&self) -> bool {
        self.endTxnOnPartition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endTxnOnPartition(&mut self, v: CommandEndTxnOnPartition) {
        self.endTxnOnPartition = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endTxnOnPartition(&mut self) -> &mut CommandEndTxnOnPartition {
        if self.endTxnOnPartition.is_none() {
            self.endTxnOnPartition.set_default();
        }
        self.endTxnOnPartition.as_mut().unwrap()
    }

    // Take field
    pub fn take_endTxnOnPartition(&mut self) -> CommandEndTxnOnPartition {
        self.endTxnOnPartition.take().unwrap_or_else(|| CommandEndTxnOnPartition::new())
    }

    // optional .pulsar.proto.CommandEndTxnOnPartitionResponse endTxnOnPartitionResponse = 59;


    pub fn get_endTxnOnPartitionResponse(&self) -> &CommandEndTxnOnPartitionResponse {
        self.endTxnOnPartitionResponse.as_ref().unwrap_or_else(|| <CommandEndTxnOnPartitionResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_endTxnOnPartitionResponse(&mut self) {
        self.endTxnOnPartitionResponse.clear();
    }

    pub fn has_endTxnOnPartitionResponse(&self) -> bool {
        self.endTxnOnPartitionResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endTxnOnPartitionResponse(&mut self, v: CommandEndTxnOnPartitionResponse) {
        self.endTxnOnPartitionResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endTxnOnPartitionResponse(&mut self) -> &mut CommandEndTxnOnPartitionResponse {
        if self.endTxnOnPartitionResponse.is_none() {
            self.endTxnOnPartitionResponse.set_default();
        }
        self.endTxnOnPartitionResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_endTxnOnPartitionResponse(&mut self) -> CommandEndTxnOnPartitionResponse {
        self.endTxnOnPartitionResponse.take().unwrap_or_else(|| CommandEndTxnOnPartitionResponse::new())
    }

    // optional .pulsar.proto.CommandEndTxnOnSubscription endTxnOnSubscription = 60;


    pub fn get_endTxnOnSubscription(&self) -> &CommandEndTxnOnSubscription {
        self.endTxnOnSubscription.as_ref().unwrap_or_else(|| <CommandEndTxnOnSubscription as ::protobuf::Message>::default_instance())
    }
    pub fn clear_endTxnOnSubscription(&mut self) {
        self.endTxnOnSubscription.clear();
    }

    pub fn has_endTxnOnSubscription(&self) -> bool {
        self.endTxnOnSubscription.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endTxnOnSubscription(&mut self, v: CommandEndTxnOnSubscription) {
        self.endTxnOnSubscription = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endTxnOnSubscription(&mut self) -> &mut CommandEndTxnOnSubscription {
        if self.endTxnOnSubscription.is_none() {
            self.endTxnOnSubscription.set_default();
        }
        self.endTxnOnSubscription.as_mut().unwrap()
    }

    // Take field
    pub fn take_endTxnOnSubscription(&mut self) -> CommandEndTxnOnSubscription {
        self.endTxnOnSubscription.take().unwrap_or_else(|| CommandEndTxnOnSubscription::new())
    }

    // optional .pulsar.proto.CommandEndTxnOnSubscriptionResponse endTxnOnSubscriptionResponse = 61;


    pub fn get_endTxnOnSubscriptionResponse(&self) -> &CommandEndTxnOnSubscriptionResponse {
        self.endTxnOnSubscriptionResponse.as_ref().unwrap_or_else(|| <CommandEndTxnOnSubscriptionResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_endTxnOnSubscriptionResponse(&mut self) {
        self.endTxnOnSubscriptionResponse.clear();
    }

    pub fn has_endTxnOnSubscriptionResponse(&self) -> bool {
        self.endTxnOnSubscriptionResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endTxnOnSubscriptionResponse(&mut self, v: CommandEndTxnOnSubscriptionResponse) {
        self.endTxnOnSubscriptionResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endTxnOnSubscriptionResponse(&mut self) -> &mut CommandEndTxnOnSubscriptionResponse {
        if self.endTxnOnSubscriptionResponse.is_none() {
            self.endTxnOnSubscriptionResponse.set_default();
        }
        self.endTxnOnSubscriptionResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_endTxnOnSubscriptionResponse(&mut self) -> CommandEndTxnOnSubscriptionResponse {
        self.endTxnOnSubscriptionResponse.take().unwrap_or_else(|| CommandEndTxnOnSubscriptionResponse::new())
    }
}

impl ::protobuf::Message for BaseCommand {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        for v in &self.connect {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.connected {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subscribe {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.producer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.send {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.send_receipt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.send_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ack {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flow {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unsubscribe {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.success {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.close_producer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.close_consumer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.producer_success {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ping {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pong {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.redeliverUnacknowledgedMessages {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.partitionMetadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.partitionMetadataResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lookupTopic {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lookupTopicResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.consumerStats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.consumerStatsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reachedEndOfTopic {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.seek {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getLastMessageId {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getLastMessageIdResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.active_consumer_change {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getTopicsOfNamespace {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getTopicsOfNamespaceResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getSchema {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getSchemaResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authChallenge {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ackResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getOrCreateSchema {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getOrCreateSchemaResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.newTxn {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.newTxnResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.addPartitionToTxn {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.addPartitionToTxnResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.addSubscriptionToTxn {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.addSubscriptionToTxnResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.endTxn {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.endTxnResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.endTxnOnPartition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.endTxnOnPartitionResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.endTxnOnSubscription {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.endTxnOnSubscriptionResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.connect)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.connected)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subscribe)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.producer)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.send)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.send_receipt)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.send_error)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ack)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flow)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unsubscribe)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.success)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.close_producer)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.close_consumer)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.producer_success)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ping)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pong)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.redeliverUnacknowledgedMessages)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.partitionMetadata)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.partitionMetadataResponse)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lookupTopic)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lookupTopicResponse)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.consumerStats)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.consumerStatsResponse)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reachedEndOfTopic)?;
                },
                28 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.seek)?;
                },
                29 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getLastMessageId)?;
                },
                30 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getLastMessageIdResponse)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.active_consumer_change)?;
                },
                32 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getTopicsOfNamespace)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getTopicsOfNamespaceResponse)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getSchema)?;
                },
                35 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getSchemaResponse)?;
                },
                36 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authChallenge)?;
                },
                37 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authResponse)?;
                },
                38 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ackResponse)?;
                },
                39 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getOrCreateSchema)?;
                },
                40 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getOrCreateSchemaResponse)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.newTxn)?;
                },
                51 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.newTxnResponse)?;
                },
                52 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.addPartitionToTxn)?;
                },
                53 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.addPartitionToTxnResponse)?;
                },
                54 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.addSubscriptionToTxn)?;
                },
                55 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.addSubscriptionToTxnResponse)?;
                },
                56 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.endTxn)?;
                },
                57 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.endTxnResponse)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.endTxnOnPartition)?;
                },
                59 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.endTxnOnPartitionResponse)?;
                },
                60 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.endTxnOnSubscription)?;
                },
                61 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.endTxnOnSubscriptionResponse)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.connect.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.connected.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.subscribe.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.producer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.send.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.send_receipt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.send_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ack.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.flow.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unsubscribe.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.success.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.close_producer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.close_consumer.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.producer_success.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ping.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pong.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.redeliverUnacknowledgedMessages.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.partitionMetadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.partitionMetadataResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lookupTopic.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lookupTopicResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.consumerStats.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.consumerStatsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reachedEndOfTopic.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.seek.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getLastMessageId.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getLastMessageIdResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.active_consumer_change.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getTopicsOfNamespace.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getTopicsOfNamespaceResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getSchema.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getSchemaResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.authChallenge.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.authResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ackResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getOrCreateSchema.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getOrCreateSchemaResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.newTxn.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.newTxnResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.addPartitionToTxn.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.addPartitionToTxnResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.addSubscriptionToTxn.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.addSubscriptionToTxnResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.endTxn.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.endTxnResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.endTxnOnPartition.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.endTxnOnPartitionResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.endTxnOnSubscription.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.endTxnOnSubscriptionResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.connect.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.connected.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.subscribe.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.producer.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.send.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.send_receipt.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.send_error.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ack.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.flow.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unsubscribe.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.success.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.close_producer.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.close_consumer.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.producer_success.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ping.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pong.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.redeliverUnacknowledgedMessages.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.partitionMetadata.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.partitionMetadataResponse.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lookupTopic.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lookupTopicResponse.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.consumerStats.as_ref() {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.consumerStatsResponse.as_ref() {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reachedEndOfTopic.as_ref() {
            os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.seek.as_ref() {
            os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getLastMessageId.as_ref() {
            os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getLastMessageIdResponse.as_ref() {
            os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.active_consumer_change.as_ref() {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getTopicsOfNamespace.as_ref() {
            os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getTopicsOfNamespaceResponse.as_ref() {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getSchema.as_ref() {
            os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getSchemaResponse.as_ref() {
            os.write_tag(35, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.authChallenge.as_ref() {
            os.write_tag(36, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.authResponse.as_ref() {
            os.write_tag(37, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ackResponse.as_ref() {
            os.write_tag(38, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getOrCreateSchema.as_ref() {
            os.write_tag(39, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getOrCreateSchemaResponse.as_ref() {
            os.write_tag(40, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.newTxn.as_ref() {
            os.write_tag(50, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.newTxnResponse.as_ref() {
            os.write_tag(51, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.addPartitionToTxn.as_ref() {
            os.write_tag(52, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.addPartitionToTxnResponse.as_ref() {
            os.write_tag(53, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.addSubscriptionToTxn.as_ref() {
            os.write_tag(54, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.addSubscriptionToTxnResponse.as_ref() {
            os.write_tag(55, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.endTxn.as_ref() {
            os.write_tag(56, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.endTxnResponse.as_ref() {
            os.write_tag(57, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.endTxnOnPartition.as_ref() {
            os.write_tag(58, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.endTxnOnPartitionResponse.as_ref() {
            os.write_tag(59, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.endTxnOnSubscription.as_ref() {
            os.write_tag(60, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.endTxnOnSubscriptionResponse.as_ref() {
            os.write_tag(61, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BaseCommand {
        BaseCommand::new()
    }

    fn default_instance() -> &'static BaseCommand {
        static instance: ::protobuf::rt::LazyV2<BaseCommand> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BaseCommand::new)
    }
}

impl ::protobuf::Clear for BaseCommand {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.connect.clear();
        self.connected.clear();
        self.subscribe.clear();
        self.producer.clear();
        self.send.clear();
        self.send_receipt.clear();
        self.send_error.clear();
        self.message.clear();
        self.ack.clear();
        self.flow.clear();
        self.unsubscribe.clear();
        self.success.clear();
        self.error.clear();
        self.close_producer.clear();
        self.close_consumer.clear();
        self.producer_success.clear();
        self.ping.clear();
        self.pong.clear();
        self.redeliverUnacknowledgedMessages.clear();
        self.partitionMetadata.clear();
        self.partitionMetadataResponse.clear();
        self.lookupTopic.clear();
        self.lookupTopicResponse.clear();
        self.consumerStats.clear();
        self.consumerStatsResponse.clear();
        self.reachedEndOfTopic.clear();
        self.seek.clear();
        self.getLastMessageId.clear();
        self.getLastMessageIdResponse.clear();
        self.active_consumer_change.clear();
        self.getTopicsOfNamespace.clear();
        self.getTopicsOfNamespaceResponse.clear();
        self.getSchema.clear();
        self.getSchemaResponse.clear();
        self.authChallenge.clear();
        self.authResponse.clear();
        self.ackResponse.clear();
        self.getOrCreateSchema.clear();
        self.getOrCreateSchemaResponse.clear();
        self.newTxn.clear();
        self.newTxnResponse.clear();
        self.addPartitionToTxn.clear();
        self.addPartitionToTxnResponse.clear();
        self.addSubscriptionToTxn.clear();
        self.addSubscriptionToTxnResponse.clear();
        self.endTxn.clear();
        self.endTxnResponse.clear();
        self.endTxnOnPartition.clear();
        self.endTxnOnPartitionResponse.clear();
        self.endTxnOnSubscription.clear();
        self.endTxnOnSubscriptionResponse.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for BaseCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BaseCommand_Type {
    CONNECT = 2,
    CONNECTED = 3,
    SUBSCRIBE = 4,
    PRODUCER = 5,
    SEND = 6,
    SEND_RECEIPT = 7,
    SEND_ERROR = 8,
    MESSAGE = 9,
    ACK = 10,
    FLOW = 11,
    UNSUBSCRIBE = 12,
    SUCCESS = 13,
    ERROR = 14,
    CLOSE_PRODUCER = 15,
    CLOSE_CONSUMER = 16,
    PRODUCER_SUCCESS = 17,
    PING = 18,
    PONG = 19,
    REDELIVER_UNACKNOWLEDGED_MESSAGES = 20,
    PARTITIONED_METADATA = 21,
    PARTITIONED_METADATA_RESPONSE = 22,
    LOOKUP = 23,
    LOOKUP_RESPONSE = 24,
    CONSUMER_STATS = 25,
    CONSUMER_STATS_RESPONSE = 26,
    REACHED_END_OF_TOPIC = 27,
    SEEK = 28,
    GET_LAST_MESSAGE_ID = 29,
    GET_LAST_MESSAGE_ID_RESPONSE = 30,
    ACTIVE_CONSUMER_CHANGE = 31,
    GET_TOPICS_OF_NAMESPACE = 32,
    GET_TOPICS_OF_NAMESPACE_RESPONSE = 33,
    GET_SCHEMA = 34,
    GET_SCHEMA_RESPONSE = 35,
    AUTH_CHALLENGE = 36,
    AUTH_RESPONSE = 37,
    ACK_RESPONSE = 38,
    GET_OR_CREATE_SCHEMA = 39,
    GET_OR_CREATE_SCHEMA_RESPONSE = 40,
    NEW_TXN = 50,
    NEW_TXN_RESPONSE = 51,
    ADD_PARTITION_TO_TXN = 52,
    ADD_PARTITION_TO_TXN_RESPONSE = 53,
    ADD_SUBSCRIPTION_TO_TXN = 54,
    ADD_SUBSCRIPTION_TO_TXN_RESPONSE = 55,
    END_TXN = 56,
    END_TXN_RESPONSE = 57,
    END_TXN_ON_PARTITION = 58,
    END_TXN_ON_PARTITION_RESPONSE = 59,
    END_TXN_ON_SUBSCRIPTION = 60,
    END_TXN_ON_SUBSCRIPTION_RESPONSE = 61,
}

impl ::protobuf::ProtobufEnum for BaseCommand_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BaseCommand_Type> {
        match value {
            2 => ::std::option::Option::Some(BaseCommand_Type::CONNECT),
            3 => ::std::option::Option::Some(BaseCommand_Type::CONNECTED),
            4 => ::std::option::Option::Some(BaseCommand_Type::SUBSCRIBE),
            5 => ::std::option::Option::Some(BaseCommand_Type::PRODUCER),
            6 => ::std::option::Option::Some(BaseCommand_Type::SEND),
            7 => ::std::option::Option::Some(BaseCommand_Type::SEND_RECEIPT),
            8 => ::std::option::Option::Some(BaseCommand_Type::SEND_ERROR),
            9 => ::std::option::Option::Some(BaseCommand_Type::MESSAGE),
            10 => ::std::option::Option::Some(BaseCommand_Type::ACK),
            11 => ::std::option::Option::Some(BaseCommand_Type::FLOW),
            12 => ::std::option::Option::Some(BaseCommand_Type::UNSUBSCRIBE),
            13 => ::std::option::Option::Some(BaseCommand_Type::SUCCESS),
            14 => ::std::option::Option::Some(BaseCommand_Type::ERROR),
            15 => ::std::option::Option::Some(BaseCommand_Type::CLOSE_PRODUCER),
            16 => ::std::option::Option::Some(BaseCommand_Type::CLOSE_CONSUMER),
            17 => ::std::option::Option::Some(BaseCommand_Type::PRODUCER_SUCCESS),
            18 => ::std::option::Option::Some(BaseCommand_Type::PING),
            19 => ::std::option::Option::Some(BaseCommand_Type::PONG),
            20 => ::std::option::Option::Some(BaseCommand_Type::REDELIVER_UNACKNOWLEDGED_MESSAGES),
            21 => ::std::option::Option::Some(BaseCommand_Type::PARTITIONED_METADATA),
            22 => ::std::option::Option::Some(BaseCommand_Type::PARTITIONED_METADATA_RESPONSE),
            23 => ::std::option::Option::Some(BaseCommand_Type::LOOKUP),
            24 => ::std::option::Option::Some(BaseCommand_Type::LOOKUP_RESPONSE),
            25 => ::std::option::Option::Some(BaseCommand_Type::CONSUMER_STATS),
            26 => ::std::option::Option::Some(BaseCommand_Type::CONSUMER_STATS_RESPONSE),
            27 => ::std::option::Option::Some(BaseCommand_Type::REACHED_END_OF_TOPIC),
            28 => ::std::option::Option::Some(BaseCommand_Type::SEEK),
            29 => ::std::option::Option::Some(BaseCommand_Type::GET_LAST_MESSAGE_ID),
            30 => ::std::option::Option::Some(BaseCommand_Type::GET_LAST_MESSAGE_ID_RESPONSE),
            31 => ::std::option::Option::Some(BaseCommand_Type::ACTIVE_CONSUMER_CHANGE),
            32 => ::std::option::Option::Some(BaseCommand_Type::GET_TOPICS_OF_NAMESPACE),
            33 => ::std::option::Option::Some(BaseCommand_Type::GET_TOPICS_OF_NAMESPACE_RESPONSE),
            34 => ::std::option::Option::Some(BaseCommand_Type::GET_SCHEMA),
            35 => ::std::option::Option::Some(BaseCommand_Type::GET_SCHEMA_RESPONSE),
            36 => ::std::option::Option::Some(BaseCommand_Type::AUTH_CHALLENGE),
            37 => ::std::option::Option::Some(BaseCommand_Type::AUTH_RESPONSE),
            38 => ::std::option::Option::Some(BaseCommand_Type::ACK_RESPONSE),
            39 => ::std::option::Option::Some(BaseCommand_Type::GET_OR_CREATE_SCHEMA),
            40 => ::std::option::Option::Some(BaseCommand_Type::GET_OR_CREATE_SCHEMA_RESPONSE),
            50 => ::std::option::Option::Some(BaseCommand_Type::NEW_TXN),
            51 => ::std::option::Option::Some(BaseCommand_Type::NEW_TXN_RESPONSE),
            52 => ::std::option::Option::Some(BaseCommand_Type::ADD_PARTITION_TO_TXN),
            53 => ::std::option::Option::Some(BaseCommand_Type::ADD_PARTITION_TO_TXN_RESPONSE),
            54 => ::std::option::Option::Some(BaseCommand_Type::ADD_SUBSCRIPTION_TO_TXN),
            55 => ::std::option::Option::Some(BaseCommand_Type::ADD_SUBSCRIPTION_TO_TXN_RESPONSE),
            56 => ::std::option::Option::Some(BaseCommand_Type::END_TXN),
            57 => ::std::option::Option::Some(BaseCommand_Type::END_TXN_RESPONSE),
            58 => ::std::option::Option::Some(BaseCommand_Type::END_TXN_ON_PARTITION),
            59 => ::std::option::Option::Some(BaseCommand_Type::END_TXN_ON_PARTITION_RESPONSE),
            60 => ::std::option::Option::Some(BaseCommand_Type::END_TXN_ON_SUBSCRIPTION),
            61 => ::std::option::Option::Some(BaseCommand_Type::END_TXN_ON_SUBSCRIPTION_RESPONSE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BaseCommand_Type] = &[
            BaseCommand_Type::CONNECT,
            BaseCommand_Type::CONNECTED,
            BaseCommand_Type::SUBSCRIBE,
            BaseCommand_Type::PRODUCER,
            BaseCommand_Type::SEND,
            BaseCommand_Type::SEND_RECEIPT,
            BaseCommand_Type::SEND_ERROR,
            BaseCommand_Type::MESSAGE,
            BaseCommand_Type::ACK,
            BaseCommand_Type::FLOW,
            BaseCommand_Type::UNSUBSCRIBE,
            BaseCommand_Type::SUCCESS,
            BaseCommand_Type::ERROR,
            BaseCommand_Type::CLOSE_PRODUCER,
            BaseCommand_Type::CLOSE_CONSUMER,
            BaseCommand_Type::PRODUCER_SUCCESS,
            BaseCommand_Type::PING,
            BaseCommand_Type::PONG,
            BaseCommand_Type::REDELIVER_UNACKNOWLEDGED_MESSAGES,
            BaseCommand_Type::PARTITIONED_METADATA,
            BaseCommand_Type::PARTITIONED_METADATA_RESPONSE,
            BaseCommand_Type::LOOKUP,
            BaseCommand_Type::LOOKUP_RESPONSE,
            BaseCommand_Type::CONSUMER_STATS,
            BaseCommand_Type::CONSUMER_STATS_RESPONSE,
            BaseCommand_Type::REACHED_END_OF_TOPIC,
            BaseCommand_Type::SEEK,
            BaseCommand_Type::GET_LAST_MESSAGE_ID,
            BaseCommand_Type::GET_LAST_MESSAGE_ID_RESPONSE,
            BaseCommand_Type::ACTIVE_CONSUMER_CHANGE,
            BaseCommand_Type::GET_TOPICS_OF_NAMESPACE,
            BaseCommand_Type::GET_TOPICS_OF_NAMESPACE_RESPONSE,
            BaseCommand_Type::GET_SCHEMA,
            BaseCommand_Type::GET_SCHEMA_RESPONSE,
            BaseCommand_Type::AUTH_CHALLENGE,
            BaseCommand_Type::AUTH_RESPONSE,
            BaseCommand_Type::ACK_RESPONSE,
            BaseCommand_Type::GET_OR_CREATE_SCHEMA,
            BaseCommand_Type::GET_OR_CREATE_SCHEMA_RESPONSE,
            BaseCommand_Type::NEW_TXN,
            BaseCommand_Type::NEW_TXN_RESPONSE,
            BaseCommand_Type::ADD_PARTITION_TO_TXN,
            BaseCommand_Type::ADD_PARTITION_TO_TXN_RESPONSE,
            BaseCommand_Type::ADD_SUBSCRIPTION_TO_TXN,
            BaseCommand_Type::ADD_SUBSCRIPTION_TO_TXN_RESPONSE,
            BaseCommand_Type::END_TXN,
            BaseCommand_Type::END_TXN_RESPONSE,
            BaseCommand_Type::END_TXN_ON_PARTITION,
            BaseCommand_Type::END_TXN_ON_PARTITION_RESPONSE,
            BaseCommand_Type::END_TXN_ON_SUBSCRIPTION,
            BaseCommand_Type::END_TXN_ON_SUBSCRIPTION_RESPONSE,
        ];
        values
    }
}

impl ::std::marker::Copy for BaseCommand_Type {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for BaseCommand_Type {
    fn default() -> Self {
        BaseCommand_Type::CONNECT
    }
}

impl ::protobuf::reflect::ProtobufValue for BaseCommand_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CompressionType {
    NONE = 0,
    LZ4 = 1,
    ZLIB = 2,
    ZSTD = 3,
    SNAPPY = 4,
}

impl ::protobuf::ProtobufEnum for CompressionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CompressionType> {
        match value {
            0 => ::std::option::Option::Some(CompressionType::NONE),
            1 => ::std::option::Option::Some(CompressionType::LZ4),
            2 => ::std::option::Option::Some(CompressionType::ZLIB),
            3 => ::std::option::Option::Some(CompressionType::ZSTD),
            4 => ::std::option::Option::Some(CompressionType::SNAPPY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CompressionType] = &[
            CompressionType::NONE,
            CompressionType::LZ4,
            CompressionType::ZLIB,
            CompressionType::ZSTD,
            CompressionType::SNAPPY,
        ];
        values
    }
}

impl ::std::marker::Copy for CompressionType {
}

impl ::std::default::Default for CompressionType {
    fn default() -> Self {
        CompressionType::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for CompressionType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ProducerAccessMode {
    Shared = 0,
    Exclusive = 1,
    WaitForExclusive = 2,
}

impl ::protobuf::ProtobufEnum for ProducerAccessMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProducerAccessMode> {
        match value {
            0 => ::std::option::Option::Some(ProducerAccessMode::Shared),
            1 => ::std::option::Option::Some(ProducerAccessMode::Exclusive),
            2 => ::std::option::Option::Some(ProducerAccessMode::WaitForExclusive),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ProducerAccessMode] = &[
            ProducerAccessMode::Shared,
            ProducerAccessMode::Exclusive,
            ProducerAccessMode::WaitForExclusive,
        ];
        values
    }
}

impl ::std::marker::Copy for ProducerAccessMode {
}

impl ::std::default::Default for ProducerAccessMode {
    fn default() -> Self {
        ProducerAccessMode::Shared
    }
}

impl ::protobuf::reflect::ProtobufValue for ProducerAccessMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ServerError {
    UnknownError = 0,
    MetadataError = 1,
    PersistenceError = 2,
    AuthenticationError = 3,
    AuthorizationError = 4,
    ConsumerBusy = 5,
    ServiceNotReady = 6,
    ProducerBlockedQuotaExceededError = 7,
    ProducerBlockedQuotaExceededException = 8,
    ChecksumError = 9,
    UnsupportedVersionError = 10,
    TopicNotFound = 11,
    SubscriptionNotFound = 12,
    ConsumerNotFound = 13,
    TooManyRequests = 14,
    TopicTerminatedError = 15,
    ProducerBusy = 16,
    InvalidTopicName = 17,
    IncompatibleSchema = 18,
    ConsumerAssignError = 19,
    TransactionCoordinatorNotFound = 20,
    InvalidTxnStatus = 21,
    NotAllowedError = 22,
    TransactionConflict = 23,
    TransactionNotFound = 24,
    ProducerFenced = 25,
}

impl ::protobuf::ProtobufEnum for ServerError {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ServerError> {
        match value {
            0 => ::std::option::Option::Some(ServerError::UnknownError),
            1 => ::std::option::Option::Some(ServerError::MetadataError),
            2 => ::std::option::Option::Some(ServerError::PersistenceError),
            3 => ::std::option::Option::Some(ServerError::AuthenticationError),
            4 => ::std::option::Option::Some(ServerError::AuthorizationError),
            5 => ::std::option::Option::Some(ServerError::ConsumerBusy),
            6 => ::std::option::Option::Some(ServerError::ServiceNotReady),
            7 => ::std::option::Option::Some(ServerError::ProducerBlockedQuotaExceededError),
            8 => ::std::option::Option::Some(ServerError::ProducerBlockedQuotaExceededException),
            9 => ::std::option::Option::Some(ServerError::ChecksumError),
            10 => ::std::option::Option::Some(ServerError::UnsupportedVersionError),
            11 => ::std::option::Option::Some(ServerError::TopicNotFound),
            12 => ::std::option::Option::Some(ServerError::SubscriptionNotFound),
            13 => ::std::option::Option::Some(ServerError::ConsumerNotFound),
            14 => ::std::option::Option::Some(ServerError::TooManyRequests),
            15 => ::std::option::Option::Some(ServerError::TopicTerminatedError),
            16 => ::std::option::Option::Some(ServerError::ProducerBusy),
            17 => ::std::option::Option::Some(ServerError::InvalidTopicName),
            18 => ::std::option::Option::Some(ServerError::IncompatibleSchema),
            19 => ::std::option::Option::Some(ServerError::ConsumerAssignError),
            20 => ::std::option::Option::Some(ServerError::TransactionCoordinatorNotFound),
            21 => ::std::option::Option::Some(ServerError::InvalidTxnStatus),
            22 => ::std::option::Option::Some(ServerError::NotAllowedError),
            23 => ::std::option::Option::Some(ServerError::TransactionConflict),
            24 => ::std::option::Option::Some(ServerError::TransactionNotFound),
            25 => ::std::option::Option::Some(ServerError::ProducerFenced),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ServerError] = &[
            ServerError::UnknownError,
            ServerError::MetadataError,
            ServerError::PersistenceError,
            ServerError::AuthenticationError,
            ServerError::AuthorizationError,
            ServerError::ConsumerBusy,
            ServerError::ServiceNotReady,
            ServerError::ProducerBlockedQuotaExceededError,
            ServerError::ProducerBlockedQuotaExceededException,
            ServerError::ChecksumError,
            ServerError::UnsupportedVersionError,
            ServerError::TopicNotFound,
            ServerError::SubscriptionNotFound,
            ServerError::ConsumerNotFound,
            ServerError::TooManyRequests,
            ServerError::TopicTerminatedError,
            ServerError::ProducerBusy,
            ServerError::InvalidTopicName,
            ServerError::IncompatibleSchema,
            ServerError::ConsumerAssignError,
            ServerError::TransactionCoordinatorNotFound,
            ServerError::InvalidTxnStatus,
            ServerError::NotAllowedError,
            ServerError::TransactionConflict,
            ServerError::TransactionNotFound,
            ServerError::ProducerFenced,
        ];
        values
    }
}

impl ::std::marker::Copy for ServerError {
}

impl ::std::default::Default for ServerError {
    fn default() -> Self {
        ServerError::UnknownError
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerError {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AuthMethod {
    AuthMethodNone = 0,
    AuthMethodYcaV1 = 1,
    AuthMethodAthens = 2,
}

impl ::protobuf::ProtobufEnum for AuthMethod {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuthMethod> {
        match value {
            0 => ::std::option::Option::Some(AuthMethod::AuthMethodNone),
            1 => ::std::option::Option::Some(AuthMethod::AuthMethodYcaV1),
            2 => ::std::option::Option::Some(AuthMethod::AuthMethodAthens),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AuthMethod] = &[
            AuthMethod::AuthMethodNone,
            AuthMethod::AuthMethodYcaV1,
            AuthMethod::AuthMethodAthens,
        ];
        values
    }
}

impl ::std::marker::Copy for AuthMethod {
}

impl ::std::default::Default for AuthMethod {
    fn default() -> Self {
        AuthMethod::AuthMethodNone
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthMethod {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ProtocolVersion {
    v0 = 0,
    v1 = 1,
    v2 = 2,
    v3 = 3,
    v4 = 4,
    v5 = 5,
    v6 = 6,
    v7 = 7,
    v8 = 8,
    v9 = 9,
    v10 = 10,
    v11 = 11,
    v12 = 12,
    v13 = 13,
    v14 = 14,
    v15 = 15,
    v16 = 16,
    v17 = 17,
}

impl ::protobuf::ProtobufEnum for ProtocolVersion {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtocolVersion> {
        match value {
            0 => ::std::option::Option::Some(ProtocolVersion::v0),
            1 => ::std::option::Option::Some(ProtocolVersion::v1),
            2 => ::std::option::Option::Some(ProtocolVersion::v2),
            3 => ::std::option::Option::Some(ProtocolVersion::v3),
            4 => ::std::option::Option::Some(ProtocolVersion::v4),
            5 => ::std::option::Option::Some(ProtocolVersion::v5),
            6 => ::std::option::Option::Some(ProtocolVersion::v6),
            7 => ::std::option::Option::Some(ProtocolVersion::v7),
            8 => ::std::option::Option::Some(ProtocolVersion::v8),
            9 => ::std::option::Option::Some(ProtocolVersion::v9),
            10 => ::std::option::Option::Some(ProtocolVersion::v10),
            11 => ::std::option::Option::Some(ProtocolVersion::v11),
            12 => ::std::option::Option::Some(ProtocolVersion::v12),
            13 => ::std::option::Option::Some(ProtocolVersion::v13),
            14 => ::std::option::Option::Some(ProtocolVersion::v14),
            15 => ::std::option::Option::Some(ProtocolVersion::v15),
            16 => ::std::option::Option::Some(ProtocolVersion::v16),
            17 => ::std::option::Option::Some(ProtocolVersion::v17),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ProtocolVersion] = &[
            ProtocolVersion::v0,
            ProtocolVersion::v1,
            ProtocolVersion::v2,
            ProtocolVersion::v3,
            ProtocolVersion::v4,
            ProtocolVersion::v5,
            ProtocolVersion::v6,
            ProtocolVersion::v7,
            ProtocolVersion::v8,
            ProtocolVersion::v9,
            ProtocolVersion::v10,
            ProtocolVersion::v11,
            ProtocolVersion::v12,
            ProtocolVersion::v13,
            ProtocolVersion::v14,
            ProtocolVersion::v15,
            ProtocolVersion::v16,
            ProtocolVersion::v17,
        ];
        values
    }
}

impl ::std::marker::Copy for ProtocolVersion {
}

impl ::std::default::Default for ProtocolVersion {
    fn default() -> Self {
        ProtocolVersion::v0
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtocolVersion {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum KeySharedMode {
    AUTO_SPLIT = 0,
    STICKY = 1,
}

impl ::protobuf::ProtobufEnum for KeySharedMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<KeySharedMode> {
        match value {
            0 => ::std::option::Option::Some(KeySharedMode::AUTO_SPLIT),
            1 => ::std::option::Option::Some(KeySharedMode::STICKY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [KeySharedMode] = &[
            KeySharedMode::AUTO_SPLIT,
            KeySharedMode::STICKY,
        ];
        values
    }
}

impl ::std::marker::Copy for KeySharedMode {
}

impl ::std::default::Default for KeySharedMode {
    fn default() -> Self {
        KeySharedMode::AUTO_SPLIT
    }
}

impl ::protobuf::reflect::ProtobufValue for KeySharedMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TxnAction {
    COMMIT = 0,
    ABORT = 1,
}

impl ::protobuf::ProtobufEnum for TxnAction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TxnAction> {
        match value {
            0 => ::std::option::Option::Some(TxnAction::COMMIT),
            1 => ::std::option::Option::Some(TxnAction::ABORT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TxnAction] = &[
            TxnAction::COMMIT,
            TxnAction::ABORT,
        ];
        values
    }
}

impl ::std::marker::Copy for TxnAction {
}

impl ::std::default::Default for TxnAction {
    fn default() -> Self {
        TxnAction::COMMIT
    }
}

impl ::protobuf::reflect::ProtobufValue for TxnAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}
